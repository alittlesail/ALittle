
namespace ALittle;

private var __floor = Math_Floor;
private var __remove = List_Remove;
private var __sin = Math_Sin;

public class ScrollList : DisplayView
{
    private double _drag_delta_x;
    private double _drag_delta_y;
    private List<double> _drag_delta_table;
    private int _drag_delta_table_count;
    private double _drag_rate;
    private LoopFunction _drag_delta_loop_y;
    private LoopLinear _drag_loop_y;
    private LoopFunction _drag_delta_loop_x;
    private LoopLinear _drag_loop_x;

    private ScrollBar _scroll_bar;
    private LoopList _scroll_bar_loop;
    private bool _open_extends_drag;
    private LoopFunction _clip_loop;
    private bool _clip_atonce;

    private int _drag_time;
    private double _max_speed;

    private double _linear_height;
    private double _linear_width;

    private DisplayObject _loading_show_up;
    private DisplayObject _loading_show_down;
    private int _type;
    
    private Linear _scroll_linear;

    public ctor(ControlSystem ctrl_sys)
    {
        this._width = 0;
        this._height = 0;
    
        this._drag_delta_x = 0;
        this._drag_delta_y = 0;
        this._drag_delta_table = new List<double>();  // 记录拖动的偏移量,数组记录,防止个别drag事件的影响
        this._drag_delta_table_count = 0;
        this._drag_rate = 0.2;
        // this._drag_delta_loop_y = null;    // 惯性移动的loop
        // this._drag_loop_y = null;    // 弹性效果loop
        // this._drag_delta_loop_x = null;    // x轴惯性移动的loop
        // this._drag_loop_x = null;    // x轴弹性效果loop
        // this._scroll_bar = null;    // 右侧滚动条
        // this._scroll_bar_loop = null;    // 滚动条透明度loop
        this._open_extends_drag = false;    // 回弹惯性开关
        // this._clip_loop = null;    // 裁剪loop
        this._clip_atonce = false; // 是否立即裁剪
    
        this._drag_time = 0;        // 最后一次drag时间
    
        this._max_speed = 40;

        // this._loading_show_up = null; // 正在加载的界面显示
        // this._loading_show_down = null; // 正在加载的界面显示
    
        this._type = UIEnumTypes.TYPE_V;    // 默认y轴滚动
    
        this._scroll_linear = new Linear(this._ctrl_sys);    // linear
        this._scroll_linear.width_type = UIEnumTypes.SIZE_MARGIN;
        this._scroll_linear.type = UIEnumTypes.TYPE_V;
        DisplayView.AddChild(this, this._scroll_linear);
        this._scroll_linear.AddEventListener(this, this.HandleLinearResize);
        this._pickup_rect = true;
        this._pickup_child = true;
        this._pickup_this = true;
        this._can_scroll = true;
    
        this.AddEventListener(this, this.HandleMButtonWheel);
        this.AddEventListener(this, this.HandleDrag);
        this.AddEventListener(this, this.HandleDragEnd);
        this.AddEventListener(this, this.HandleDragBegin);
    
        // 延迟裁剪
        this.RefreshClipDisLine();
    }
    
    //////////////////////////////////////////////////////////////////////////////////////////-
    // 获取子控件的索引
    public fun GetChildIndex(DisplayObject child) : int
    {
        return this._scroll_linear.GetChildIndex(child);
    }
    // 设置子控件的索引
    public fun SetChildIndex(DisplayObject child, int index) : bool
    {
        this._scroll_linear.SetChildIndex(child, index);
        this.RefreshClipDisLine();
        return true;
    }
    // 根据索引获取子控件
    public fun GetChildByIndex(int index) : DisplayObject
    {
        return this._scroll_linear.GetChildByIndex(index);
    }
    // 获取所有子控件
    public get childs() : List<DisplayObject>
    {
        return this._scroll_linear.childs;
    }
    // 获取子控件数量
    public get child_count() : int
    {
        return this._scroll_linear.child_count;
    }
    // 设置类型
    public set type(int value)
    {
        if (this._type == value)
            return;
        this._type = value;
    
        if (this._type == UIEnumTypes.TYPE_H)
        {
            this._scroll_linear.width_type = UIEnumTypes.SIZE_ABS;
            this._scroll_linear.height_type = UIEnumTypes.SIZE_MARGIN;
            this._scroll_linear.type = UIEnumTypes.TYPE_H;
        }
        else
        {
            this._scroll_linear.width_type = UIEnumTypes.SIZE_MARGIN;
            this._scroll_linear.height_type = UIEnumTypes.SIZE_ABS;
            this._scroll_linear.type = UIEnumTypes.TYPE_V;
        }
        this.RefreshChild(false);
    }
    public get type() : int
    {
        return this._type;
    }
    public fun AddChild(DisplayObject child, [Nullable] int index) : bool
    {
        if (child == null) return false;
        if (this._scroll_linear.AddChild(child, index) == false) return false;
		child._logic_parent = this;

        this.RefreshChild(false);
        return true;
    }

    public fun RemoveChild(DisplayObject child) : bool
    {
        if (child == null)
            return false;
            
        if (this._scroll_linear.RemoveChild(child) == false)
            return false;
            
        this.RefreshChild(false);
        return true;
    }

    public fun SpliceChild(int index, [Nullable] int count) : int
    {
        var result = this._scroll_linear.SpliceChild(index, count);
        if (result != 0) this.RefreshChild(false);
        return result;
    }
    
    // 特殊效果添加控件
    // 使用该接口，只能添加第一个或最后一个控件，添加第一个控件时，将保持下边界不变，添加最后一个控件将保持上边界不变
    // up true 第一个 false 最后一个
    public fun AddChildEffect(DisplayObject child, bool up) : bool
    {
        if (child == null)
            return false;
    
        if (up)
        {
            if (this._type == UIEnumTypes.TYPE_H)
            {
                var target_value = this._scroll_linear.x + this._scroll_linear.width;
                if (this._scroll_linear.AddChild(child, 1) == false)
                    return false;
                    
                this._scroll_linear.x = target_value - this._scroll_linear.width;
            }
            else
            {
                var target_value = this._scroll_linear.y + this._scroll_linear.height;
                if (this._scroll_linear.AddChild(child, 1) == false)
                    return false;
                    
                this._scroll_linear.y = target_value - this._scroll_linear.height;
            }
        }
        else
        {
            if (this._scroll_linear.AddChild(child) == false)
                return false;
        }
        this.RefreshChild(false);
        return true;
    }
    
    // 特殊效果移除控件
    // up true 移除第一个控件，false移除最后一个控件
    // loop true 在移除控件后，用动画效果重设边界，false 直接重设边界
    public fun RemoveChildEffect(bool up, bool loop) : bool
    {
        if (up)
        {
            if (this._type == UIEnumTypes.TYPE_H)
            {
                var child = this._scroll_linear.GetChildByIndex(1);
                var target_value = this._scroll_linear.x + this._scroll_linear.width;
                if (this._scroll_linear.RemoveChild(child) == false)
                    return false;
                    
                this._scroll_linear.x = target_value - this._scroll_linear.width;
            }
            else
            {
                var child = this._scroll_linear.GetChildByIndex(1);
                var target_value = this._scroll_linear.y + this._scroll_linear.height;
                if (this._scroll_linear.RemoveChild(child) == false)
                    return false;
                    
                this._scroll_linear.y = target_value - this._scroll_linear.height;
            }
        }
        else
        {
            var child = this._scroll_linear.GetChildByIndex(this._scroll_linear.child_count);
            if (this._scroll_linear.RemoveChild(child) == false)
                return false;
        }
        if (loop)
            this.RefreshChild(true);
        else
            this.RefreshChild(false);
        return true;
    }
    
    // 检查是否存在某个子控件
    public fun HasChild(DisplayObject child) : bool
    {
        return this._scroll_linear.HasChild(child);
    }
    // 移除所有子控件
    public fun RemoveAllChild()
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            A_LoopSystem.RemoveUpdater(this._drag_loop_x);
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_x);
            this._scroll_linear.x = 0;
        }
        else
        {
            A_LoopSystem.RemoveUpdater(this._drag_loop_y);
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_y);
            this._scroll_linear.y = 0;
        }
        this._scroll_linear.RemoveAllChild();
        this.UpdateLoadingShow();
        this.AdjustScrollBar();
    }
    
    // 子控件变化位置刷新
    protected fun RefreshChild(bool loop)
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            var linear_width = this._scroll_linear.width;
            var target_x:double = null;
            // 确定目标
            if (linear_width >= this._width)
            {
                if (this._scroll_linear.x > 0)
                    target_x = 0;
                elseif (this._scroll_linear.x < -linear_width + this._width)
                    target_x = -linear_width + this._width;
            }
            else
            {
                target_x = 0;
            }
            if (target_x == null || target_x == this._scroll_linear.x)
            {
                A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                this.RefreshClipDisLine();
                this.AdjustScrollBar();
                return;
            }
            // 之前正在loop,就用原来的速度移动向目标位置
            if (this._drag_loop_x != null && this._drag_loop_x.IsCompleted() == false)
            {
                var speed = this._drag_loop_x.speed;
                var func = bind(ScrollList.RefreshClipDisLine, this, null);
                A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                var time = (target_x - this._scroll_linear.x) / speed;
                this._drag_loop_x = new LoopLinear(this._scroll_linear, "x", target_x, __floor(time), 0, func);
                A_LoopSystem.AddUpdater(this._drag_loop_x);
            }
            else
            {
                // 之前没有在loop,判断是否需要用动画效果移动向目标位置
                if (loop)
                {
                    var func = bind(ScrollList.RefreshClipDisLine, this, null);
                    A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                    this._drag_loop_x = new LoopLinear(this._scroll_linear, "x", target_x, 200, 0, func);
                    A_LoopSystem.AddUpdater(this._drag_loop_x);
                }
                else
                {
                    this._scroll_linear.x = target_x;
                }
            }
        }
        else
        {
            var linear_height = this._scroll_linear.height;
            var target_y:double = null;
            // 确定目标
            if (linear_height >= this._height)
            {
                if (this._scroll_linear.y > 0)
                    target_y = 0;
                elseif (this._scroll_linear.y < -linear_height + this._height)
                    target_y = -linear_height + this._height;
            }
            else
            {
                target_y = 0;
            }
            if (target_y == null || target_y == this._scroll_linear.y)
            {
                A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                this.RefreshClipDisLine();
                this.AdjustScrollBar();
                return;
            }
            // 之前正在loop,就用原来的速度移动向目标位置
            if (this._drag_loop_y != null && this._drag_loop_y.IsCompleted() == false)
            {
                var speed = this._drag_loop_y.speed;
                var func = bind(ScrollList.RefreshClipDisLine, this, null);
                A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                var time = (target_y - this._scroll_linear.y) / speed;
                this._drag_loop_y = new LoopLinear(this._scroll_linear, "y", target_y, __floor(time), 0, func);
                A_LoopSystem.AddUpdater(this._drag_loop_y);
            }
            else
            {
                // 之前没有在loop,判断是否需要用动画效果移动向目标位置
                if (loop)
                {
                    var func = bind(ScrollList.RefreshClipDisLine, this, null);
                    A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                    this._drag_loop_y = new LoopLinear(this._scroll_linear, "y", target_y, 200, 0, func);
                    A_LoopSystem.AddUpdater(this._drag_loop_y);
                }
                else
                {
                    this._scroll_linear.y = target_y;
                }
            }
        }
        this.RefreshClipDisLine();
        this.AdjustScrollBar();
    }
    
    ////////////////////////////////////////////////////////////
    public set clip_atonce(bool value)
    {
        this._clip_atonce = value;
    }
    public get clip_atonce() : bool
    {
        return this._clip_atonce;
    }
    
    public set scroll_offset(double value)
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            A_LoopSystem.RemoveUpdater(this._drag_loop_x);
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_x);
    
            if (value > 0)
                value = 0;

            var total_width = this.width;
            var linear_width = this._scroll_linear.width;
            if (total_width < linear_width)
            {
                var delta = total_width - linear_width;
                if (value < delta)
                    value = delta;
            }
            this._scroll_linear.x = value;
            this.AdjustScrollBar();
        }
        else
        {
            A_LoopSystem.RemoveUpdater(this._drag_loop_y);
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_y);
    
            if (value > 0)
                value = 0;

            var total_height = this.height;
            var linear_height = this._scroll_linear.height;
            if (total_height < linear_height)
            {
                var delta = total_height - linear_height;
                if (value < delta)
                    value = delta;
            }
            this._scroll_linear.y = value;
            this.AdjustScrollBar();
        }
    }
    
    public get scroll_offset() : double
    {
        if (this._type == UIEnumTypes.TYPE_H)
            return this._scroll_linear.x;
        return this._scroll_linear.y;
    }
    
    public fun ScrollToBottom()
    {
        if (this.height >= this.real_height)
            return;
    
        this.scroll_offset = this.height - this.real_height;
    }
    
    public set gap(double value)
    {
        if (value == null) value = 0;
        this._scroll_linear.gap = value;
        this.RefreshClipDisLine();
        this.AdjustScrollBar();
    }
    
    public get gap() : double
    {
        return this._scroll_linear.gap;
    }
    
    public get real_height() : double
    {
        return this._scroll_linear.height;
    }
    
    public get real_width() : double
    {
        return this._scroll_linear.width;
    }
    
    // 高度
    public set width(double value)
    {
        if (this._type == UIEnumTypes.TYPE_V)
        {
            DisplayView.width(this, value);
            return;
        }
    
        if (this._width == value) return;
            
        this._width = value;
        if (this._width_type == UIEnumTypes.SIZE_ABS)
            this._width_value = this._width;

        this._show.SetWidth(this._width);
    
        if (this._scroll_bar != null)
        {
            var linear_width = this._scroll_linear.width;
            var rate = this._scroll_bar.offset_rate;
            if (linear_width < this._width)
                rate = 0;
                
            this._scroll_bar.width = this._width;
            this._scroll_bar.total_size = linear_width;
            this._scroll_bar.show_size = this._width;
            this._scroll_bar.offset_rate = rate;
            this._scroll_bar.offset_step = 0.1;
            var x = 0.0;
            if (linear_width > this._width)
            {
                var total_width = linear_width - this._width;
                x = -total_width * rate;
            }
            this._scroll_linear.x = x;
        }
    
        this.RefreshClipDisLine();
    }
    
    // 高度
    public set height(double value)
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            DisplayView.height(this, value);
            return;
        }
    
        if (this._height == value) return;
            
        this._height = value;
        if (this._height_type == UIEnumTypes.SIZE_ABS)
            this._height_value = this._height;

        this._show.SetHeight(this._height);

        if (this._scroll_bar != null)
        {
            var linear_height = this._scroll_linear.height;
            var rate = this._scroll_bar.offset_rate;
            if (linear_height < this._height)
                rate = 0;
                
            this._scroll_bar.height = this._height;
            this._scroll_bar.total_size = linear_height;
            this._scroll_bar.show_size = this._height;
            this._scroll_bar.offset_rate = rate;
            this._scroll_bar.offset_step = 0.1;
            var y = 0.0;
            if (linear_height > this._height)
            {
                var total_height = linear_height - this._height;
                y = -total_height * rate;
            }
            this._scroll_linear.y = y;
        }
    
        this.RefreshClipDisLine();
    }
    
    // 滚动条
    public set right_scrollbar(ScrollBar value)
    {
        if (this._scroll_bar != null)
        {
            A_LoopSystem.RemoveUpdater(this._scroll_bar_loop);
            DisplayView.RemoveChild(this, this._scroll_bar);
            this._scroll_bar.RemoveEventListener(this, this.HandleRightScrollBarChange);
            this._scroll_bar.RemoveEventListener(this, this.HandleRightScrollBarChangeEnd);
        }
        this._scroll_bar = value;
        if (this._scroll_bar != null)
        {
            if (this._type == UIEnumTypes.TYPE_H)
            {
                this._scroll_bar.alpha = 0;
                this._scroll_bar.visible = false;
                this._scroll_bar.type = UIEnumTypes.TYPE_H;
                this._scroll_bar.y_type = UIEnumTypes.POS_ALIGN_ENDING;
                DisplayView.AddChild(this, this._scroll_bar);
                this._scroll_bar.AddEventListener(this, this.HandleRightScrollBarChange);
                this._scroll_bar.AddEventListener(this, this.HandleRightScrollBarChangeEnd);
                this._scroll_bar.width = this._width;
                this._scroll_bar.x = 0;
    
                this._scroll_bar.total_size = this._scroll_linear.width;
                this._scroll_bar.show_size = this._width;
                this._scroll_bar.offset_rate = 0;
                this._scroll_bar.offset_step = 0.1;
            }
            else
            {
                this._scroll_bar.alpha = 0;
                this._scroll_bar.visible = false;
                this._scroll_bar.type = UIEnumTypes.TYPE_V;
                this._scroll_bar.x_type = UIEnumTypes.POS_ALIGN_ENDING;
                DisplayView.AddChild(this, this._scroll_bar);
                this._scroll_bar.AddEventListener(this, this.HandleRightScrollBarChange);
                this._scroll_bar.AddEventListener(this, this.HandleRightScrollBarChangeEnd);
                this._scroll_bar.height = this._height;
                this._scroll_bar.y = 0;
    
                this._scroll_bar.total_size = this._scroll_linear.height;
                this._scroll_bar.show_size = this._height;
                this._scroll_bar.offset_rate = 0;
                this._scroll_bar.offset_step = 0.1;
            }
        }
    }
    public get right_scrollbar() : ScrollBar
    {
        return this._scroll_bar;
    }
    //  重置滚动条
    public fun AdjustScrollBar()
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            var linear_width = this._scroll_linear.width;
    
            if (this._scroll_bar != null)
            {
                var rate = 0.0;
                if (linear_width <= this._width)
                    rate = 0;
                else
                    rate = -this._scroll_linear.x / (linear_width - this._width);
                    
                this._scroll_bar.width = this._width;
                this._scroll_bar.total_size = linear_width;
                this._scroll_bar.show_size = this._width;
                this._scroll_bar.offset_rate = rate;
                this._scroll_bar.offset_step = 0.1;
            }
        }
        else
        {
            var linear_height = this._scroll_linear.height;
            if (this._scroll_bar != null)
            {
                var rate = 0.0;
                if (linear_height <= this._height)
                    rate = 0;
                else
                    rate = -this._scroll_linear.y / (linear_height - this._height);
                    
                this._scroll_bar.height = this._height;
                this._scroll_bar.total_size = linear_height;
                this._scroll_bar.show_size = this._height;
                this._scroll_bar.offset_rate = rate;
                this._scroll_bar.offset_step = 0.1;
            }
        }
    }
    
    // 获取正在加载显示控件
    public get loading_show_up() : DisplayObject
    {
        return this._loading_show_up;
    }
    
    // 设置正在加载显示控件
    public set loading_show_up(DisplayObject value)
    {
        if (this._loading_show_up != value)
        {
            DisplayView.RemoveChild(this, this._loading_show_up);
            this._loading_show_up = null;
        }
        if (value != null)
        {
            this._loading_show_up = value;
            DisplayView.AddChild(this, this._loading_show_up);
            if (this._type == UIEnumTypes.TYPE_H)
                this._loading_show_up.x = this._scroll_linear.x - this._loading_show_up.width;
            else
                this._loading_show_up.y = this._scroll_linear.y - this._loading_show_up.height;
        }
    }
    
    // 获取正在加载显示控件
    public get loading_show_down() :DisplayObject
    {
        return this._loading_show_down;
    }
    
    // 设置正在加载显示控件
    public set loading_show_down(DisplayObject value)
    {
        if (this._loading_show_down != value)
        {
            DisplayView.RemoveChild(this, this._loading_show_down);
            this._loading_show_down = null;
        }
        if (value != null)
        {
            this._loading_show_down = value;
            DisplayView.AddChild(this, this._loading_show_down);
            if (this._type == UIEnumTypes.TYPE_H)
                this._loading_show_down.x = this._scroll_linear.x + this._scroll_linear.width;
            else
                this._loading_show_down.y = this._scroll_linear.y + this._scroll_linear.height;
        }
    }
    
    // 更新正在加载的界面显示
    public fun UpdateLoadingShow()
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            if (this._loading_show_up != null)
                this._loading_show_up.x = this._scroll_linear.x - this._loading_show_up.width;
            if (this._loading_show_down != null)
                this._loading_show_down.x = this._scroll_linear.x + this._scroll_linear.width;
        }
        else
        {
            if (this._loading_show_up != null)
                this._loading_show_up.y = this._scroll_linear.y - this._loading_show_up.height;
            if (this._loading_show_down != null)
                this._loading_show_down.y = this._scroll_linear.y + this._scroll_linear.height;
        }
    }
    
    public fun Layout(int index)
    {
        this._scroll_linear.Layout(index);
        this.RefreshClipDisLine();
    }

    public fun DeepLayout()
    {
        this._scroll_linear.DeepLayout();
        this.RefreshClipDisLine();
    }
    ////////////////////////////////////////////////////////////////////////////////////////
    // linear resize事件
    protected fun HandleLinearResize(UIResizeEvent event)
    {
        this.AdjustScrollBar();
        this.RefreshClipDisLine();
    }
    // 滚动条 change事件
    protected fun HandleRightScrollBarChange(UIChangedEvent event)
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            var rate = this._scroll_bar.offset_rate;
            var x = 0.0;
            var linear_width = this._scroll_linear.width;
            if (linear_width > this._width)
            {
                var total_width = linear_width - this._width;
                x = -total_width * rate;
            }
            this._scroll_linear.x = x;
        }
        else
        {
            var rate = this._scroll_bar.offset_rate;
            var y = 0.0;
            var linear_height = this._scroll_linear.height;
            if (linear_height > this._height)
            {
                var total_height = linear_height - this._height;
                y = -total_height * rate;
            }
            this._scroll_linear.y = y;
        }
        this.RefreshClipDisLine();
    
        // 显示滚动条
        this.ShowRightScrollBar();
    }
    // 滚动条 change事件
    protected fun HandleRightScrollBarChangeEnd(UIChangedEndEvent event)
    {
        this.HideRightScrollBar();
    }
    // 鼠标中键
    protected fun HandleMButtonWheel(UIMButtonWheelEvent event)
    {
        if (this._scroll_bar != null && event.delta_y != 0)
        {
            var offset = this._scroll_linear.height * 0.1 * event.delta_y;
            if (offset > 60) offset = 60;
            elseif (offset < -60) offset = -60;
            if (offset != 0) this._scroll_bar.offset_rate = this._scroll_bar.offset_rate - offset / this._scroll_linear.height;

            this.HandleRightScrollBarChange(null);
            this.HideRightScrollBar();
        }
    }
    public get open_extends_drag() : bool
    {
        return this._open_extends_drag;
    }
    
    public set open_extends_drag(bool value)
    {
        this._open_extends_drag = value;
    }
    // 开始滚动
    public fun HandleDragBegin(UIButtonDragBeginEvent event)
    {
        this._drag_delta_table = new List<double>();
        this._drag_delta_table_count = 0;
    
        A_LoopSystem.RemoveUpdater(this._scroll_bar_loop);
        if (this._scroll_bar != null)
        {
            this._scroll_bar.visible = true;
            this._scroll_bar.alpha = 1;
        }
    
        if (this._type == UIEnumTypes.TYPE_H)
        {
            A_LoopSystem.RemoveUpdater(this._drag_loop_x);
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_x);
        }
        else
        {
            A_LoopSystem.RemoveUpdater(this._drag_loop_y);
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_y);
        }
    }

    protected fun HandleDrag(UIButtonDragEvent event)
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            if (this._drag_delta_table_count < 3)
            {
                ++ this._drag_delta_table_count;
                this._drag_delta_table[this._drag_delta_table_count] = event.delta_x;
            }
            else
            {
                __remove(this._drag_delta_table, 1);
                this._drag_delta_table[this._drag_delta_table_count] = event.delta_x;
            }
            this._drag_time = Time_GetCurTime();

            var linear_width = this._scroll_linear.width;
    
            if (event.delta_x != 0 && this._scroll_bar != null)
            {
                // 向右拖拽
                if (event.delta_x > 0)
                {
                    var min_x = 0.0;
                    var max_x = this._width * this._drag_rate;
                    var x = this._scroll_linear.x;
                    if (x > min_x)
                    {
                        x = x + event.delta_x * __sin((1 - x / (this._width * this._drag_rate)) * 1.57);
                        if (x > max_x)
                            x = max_x;
                    }
                    else
                    {
                        x += event.delta_x;
                    }
                    if (x >= min_x && !this._open_extends_drag)
                        x = min_x;
                    this._scroll_linear.x = x;
                    if (this._scroll_bar != null)
                        this._scroll_bar.offset_rate = -x / (linear_width - this._width);
                }
                // 向左拖拽
                else
                {
                    var x = this._scroll_linear.x;
                    if (linear_width < this._width)
                    {
                        x += event.delta_x;
                        if (x < 0)
                            x = 0;
                    }        
                    else
                    {
                        var max_x = -linear_width + this._width;
                        var min_x = max_x - this._width * this._drag_rate;
                        if (x < max_x)
                        {
                            x += event.delta_x * __sin((x - min_x) / (this._width * this._drag_rate) * 1.57);
                            if (x < min_x)
                                x = min_x;
                        }
                        else
                        {
                            x += event.delta_x;
                        }
                        if (x <= max_x && !this._open_extends_drag)
                            x = max_x;
                    }
                    this._scroll_linear.x = x;
                    if (this._scroll_bar != null)
                        this._scroll_bar.offset_rate = -x / (linear_width - this._width);
                }
    
                this.RefreshClipDisLine(event.delta_x);
            }
        }
        else
        {
            if (this._drag_delta_table_count < 3)
            {
                ++ this._drag_delta_table_count;
                this._drag_delta_table[this._drag_delta_table_count] = event.delta_y;
            }
            else
            {
                __remove(this._drag_delta_table, 1);
                this._drag_delta_table[this._drag_delta_table_count] = event.delta_y;
            }
            this._drag_time = Time_GetCurTime();

            var linear_height = this._scroll_linear.height;
    
            if (event.delta_y != 0 && this._scroll_bar != null)
            {
                // 向下拖拽
                if (event.delta_y > 0)
                {
                    var min_y = 0.0;
                    var max_y = this._height * this._drag_rate;
                    var y = this._scroll_linear.y;
                    if (y > min_y)
                    {
                        y = y + event.delta_y * __sin((1 - y / (this._height * this._drag_rate)) * 1.57);
                        if (y > max_y)
                            y = max_y;
                    }
                    else
                        y += event.delta_y;
                        
                    if (y >= min_y && !this._open_extends_drag)
                        y = min_y;
                        
                    this._scroll_linear.y = y;
                    if (this._scroll_bar != null)
                        this._scroll_bar.offset_rate = -y / (linear_height - this._height);
                }
                // 向上拖拽
                else
                {
                    var y = this._scroll_linear.y;
                    if (linear_height < this._height)
                    {
                        y += event.delta_y;
                        if (y < 0)
                            y = 0;
                    }
                    else
                    {
                        var max_y = -linear_height + this._height;
                        var min_y = max_y - this._height * this._drag_rate;
                        if (y < max_y)
                        {
                            y += event.delta_y * __sin((y - min_y) / (this._height * this._drag_rate) * 1.57);
                            if (y < min_y)
                                y = min_y;
                        }
                        else
                        {
                            y += event.delta_y;
                        }
                        if (y <= max_y && !this._open_extends_drag)
                            y = max_y;
                    }
                    this._scroll_linear.y = y;
                    if (this._scroll_bar != null)
                        this._scroll_bar.offset_rate = -y / (linear_height - this._height);
                }
    
                this.RefreshClipDisLine(event.delta_y);
            }
        }
    }

    protected fun HandleDragEnd(UIButtonDragEndEvent event)
    {
        if (this._type == UIEnumTypes.TYPE_H)
        {
            var linear_width = this._scroll_linear.width;
    
            if (this._scroll_linear.x > 0)
            {
                // 开始执行返回动画
                A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                var func = bind(ScrollList.RefreshClipDisLine, this, null);
                this._drag_loop_x = new LoopLinear(this._scroll_linear, "x", 0, 200, 0, func);
                A_LoopSystem.AddUpdater(this._drag_loop_x);
                this.HideRightScrollBar();
    
                // 如果拉倒一定程度，就发送一个DRAGDOWN
                if (this._scroll_linear.x >= this._width * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragDownEvent());
                }
            }
            elseif (this._scroll_linear.x < -linear_width + this._width)
            {
                // 开始执行返回动画
                if (this._scroll_linear.x < 0)
                {
                    var func = bind(ScrollList.RefreshClipDisLine, this, null);
                    A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                    this._drag_loop_x = new LoopLinear(this._scroll_linear, "x", -linear_width + this._width, 200, 0, func);
                    A_LoopSystem.AddUpdater(this._drag_loop_x);
                    this.HideRightScrollBar();
                }
    
                // 如果拉倒一定程度，就发送一个DRAGUP
                if (this._scroll_linear.x <= -linear_width + this._width - this._width * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragUpEvent());
                }
            }
                // 惯性移动
            elseif (this._scroll_linear.x != 0 && this._scroll_linear.x != -linear_width + this._width)
            {
                // 计算惯性移动用的偏移量
                var count = this._drag_delta_table_count;
                var drag_delta_x = 0.0;
                var drag_end_time = Time_GetCurTime() - this._drag_time;
                // 快速拖动忽略最后一个drag
                if (drag_end_time < 50)
                {
                    if (count == 1 || count == 2)
                        drag_delta_x = this._drag_delta_table[1];
                    elseif (count == 3)
                        drag_delta_x = __floor((this._drag_delta_table[count - 1] + this._drag_delta_table[count - 2]) / 2);
                    else
                        drag_delta_x = 0;
                }
                else
                {
                    if (count != 0)
                        drag_delta_x = this._drag_delta_table[count];
                    else
                        drag_delta_x = 0;
                }
    
                if (drag_delta_x < 0 && drag_delta_x < -this._max_speed)
                    drag_delta_x = -this._max_speed;
                elseif (drag_delta_x > 0 && drag_delta_x > this._max_speed)
                    drag_delta_x = this._max_speed;
                    
                this._drag_delta_x = drag_delta_x;
    
                A_LoopSystem.RemoveUpdater(this._drag_delta_loop_x);
                this._drag_delta_loop_x = new LoopFunction(bind(this.RefreshLinearX, this), -1, 1, 0);
                A_LoopSystem.AddUpdater(this._drag_delta_loop_x);
            }
        }
        else
        {
            var linear_height = this._scroll_linear.height;
    
            if (this._scroll_linear.y > 0)
            {
                // 开始执行返回动画
                A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                var func = bind(ScrollList.RefreshClipDisLine, this, null);
                this._drag_loop_y = new LoopLinear(this._scroll_linear, "y", 0, 200, 0, func);
                A_LoopSystem.AddUpdater(this._drag_loop_y);
                this.HideRightScrollBar();
    
                // 如果拉倒一定程度，就发送一个DRAGDOWN
                if (this._scroll_linear.y >= this._height * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragDownEvent());
                }
            }
            elseif (this._scroll_linear.y < -linear_height + this._height)
            {
                // 开始执行返回动画
                if (this._scroll_linear.y < 0)
                {
                    var func = bind(ScrollList.RefreshClipDisLine, this, null);
                    A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                    this._drag_loop_y = new LoopLinear(this._scroll_linear, "y", -linear_height + this._height, 200, 0, func);
                    A_LoopSystem.AddUpdater(this._drag_loop_y);
                    this.HideRightScrollBar();
                }
    
                // 如果拉倒一定程度，就发送一个DRAGUP
                if (this._scroll_linear.y <= -linear_height + this._height - this._height * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragUpEvent());
                }
            }
                // 惯性移动
            elseif (this._scroll_linear.y != 0 && this._scroll_linear.y != -linear_height + this._height)
            {
                // 计算惯性移动用的偏移量
                var count = this._drag_delta_table_count;
                var drag_delta_y = 0.0;
                var drag_end_time = Time_GetCurTime() - this._drag_time;
                // 快速拖动忽略最后一个drag
                if (drag_end_time < 50)
                {
                    if (count == 1 || count == 2)
                        drag_delta_y = this._drag_delta_table[1];
                    elseif (count == 3)
                        drag_delta_y = __floor((this._drag_delta_table[count - 1] + this._drag_delta_table[count - 2]) / 2);
                    else
                        drag_delta_y = 0;
                }
                else
                {
                    if (count != 0)
                        drag_delta_y = this._drag_delta_table[count];
                    else
                        drag_delta_y = 0;
                }
    
                if (drag_delta_y < 0 && drag_delta_y < -this._max_speed)
                    drag_delta_y = -this._max_speed;
                elseif (drag_delta_y > 0 && drag_delta_y > this._max_speed)
                    drag_delta_y = this._max_speed;
                    
                this._drag_delta_y = drag_delta_y;
    
                A_LoopSystem.RemoveUpdater(this._drag_delta_loop_y);
                this._drag_delta_loop_y = new LoopFunction(bind(this.RefreshLinearY, this), -1, 1, 0);
                A_LoopSystem.AddUpdater(this._drag_delta_loop_y);
            }
        }
    }
    //////////////////////////////////////////////////////////////////////////////
    // 惯性滚动函数
    protected fun RefreshLinearX()
    {
        this._scroll_linear.x = this._scroll_linear.x + this._drag_delta_x;
        var linear_width = this._scroll_linear.width;

        var loop_end = false;
    
        if (this._drag_delta_x != 0 && this._scroll_bar != null)
        {
            // 向右拖拽
            if (this._drag_delta_x > 0)
            {
                var min_x = 0.0;
                var max_x = this._width * this._drag_rate;
                var x = this._scroll_linear.x;
                if (x > min_x)
                {
                    x = x + this._drag_delta_x * __sin((1 - x / (this._width * this._drag_rate)) * 1.57);
                    if (x > max_x)
                    {
                        x = max_x;
                        loop_end = true;
                    }
                }
                else
                    x += this._drag_delta_x;

                if (x >= min_x && !this._open_extends_drag)
                    x = min_x;

                this._scroll_linear.x = x;
                if (this._scroll_bar != null)
                    this._scroll_bar.offset_rate = -x / (linear_width - this._width);
            }
            // 向左拖拽
            else
            {
                var x = this._scroll_linear.x;
                if (linear_width < this._width)
                {
                    x += this._drag_delta_x;
                    if (x < 0)
                        x = 0;
                }
                else
                {
                    var max_x = -linear_width + this._width;
                    var min_x = max_x - this._width * this._drag_rate;
                    if (x < max_x)
                    {
                        x += this._drag_delta_x * __sin((x - min_x) / (this._width * this._drag_rate) * 1.57);
                        if (x < min_x)
                        {
                            x = min_x;
                            loop_end = true;
                        }
                    }
                    else
                        x += this._drag_delta_x;

                    if (x <= max_x && !this._open_extends_drag)
                        x = max_x;

                }
                this._scroll_linear.x = x;
                if (this._scroll_bar != null)
                    this._scroll_bar.offset_rate = -x / (linear_width - this._width);
            }
            this.RefreshClipDisLine();
        }
    
        if (this._drag_delta_x < 0)
        {
            this._drag_delta_x = this._drag_delta_x + 1;
            if (this._drag_delta_x >= 0)
                loop_end = true;
        }
        elseif (this._drag_delta_x > 0)
        {
            this._drag_delta_x = this._drag_delta_x - 1;
            if (this._drag_delta_x <= 0)
                loop_end = true;
        }
        else
        {
            loop_end = true;
        }
    
        // 惯性拖动结束
        if (loop_end)
        {
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_x);
    
            if (this._scroll_linear.x > 0)
            {
                var func = bind(ScrollList.RefreshClipDisLine, this, null);
                A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                this._drag_loop_x = new LoopLinear(this._scroll_linear, "x", 0, 200, 0, func);
                A_LoopSystem.AddUpdater(this._drag_loop_x);
    
                if (this._scroll_linear.x >= this._width * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragDownEvent());
                }
            }
            elseif (this._scroll_linear.x < -linear_width + this._width)
            {
                if (this._scroll_linear.x < 0)
                {
                    var func = bind(ScrollList.RefreshClipDisLine, this, null);
                    A_LoopSystem.RemoveUpdater(this._drag_loop_x);
                    this._drag_loop_x = new LoopLinear(this._scroll_linear, "x", -linear_width + this._width, 200, 0, func);
                    A_LoopSystem.AddUpdater(this._drag_loop_x);
                }
    
                if (this._scroll_linear.x <= -linear_width + this._width - this._width * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragUpEvent());
                }
            }
            this.HideRightScrollBar();
        }
    }
    
    // 惯性滚动函数
    protected fun RefreshLinearY()
    {
        this._scroll_linear.y = this._scroll_linear.y + this._drag_delta_y;
        var linear_height = this._scroll_linear.height;

        var loop_end = false;
    
        if (this._drag_delta_y != 0 && this._scroll_bar != null)
        {
            // 向下拖拽
            if (this._drag_delta_y > 0)
            {
                var min_y = 0.0;
                var max_y = this._height * this._drag_rate;
                var y = this._scroll_linear.y;
                if (y > min_y)
                {
                    y += this._drag_delta_y * __sin((1 - y / (this._height * this._drag_rate)) * 1.57);
                    if (y > max_y)
                    {
                        y = max_y;
                        loop_end = true;
                    }
                }
                else
                {
                    y += this._drag_delta_y;
                }
                if (y >= min_y && !this._open_extends_drag)
                    y = min_y;
                this._scroll_linear.y = y;
                if (this._scroll_bar != null)
                    this._scroll_bar.offset_rate = -y / (linear_height - this._height);
            }
            // 向上拖拽
            else
            {
                var y = this._scroll_linear.y;
                if (linear_height < this._height)
                {
                    y += this._drag_delta_y;
                    if (y < 0)
                        y = 0;
                }
                else
                {
                    var max_y = -linear_height + this._height;
                    var min_y = max_y - this._height * this._drag_rate;
                    if (y < max_y)
                    {
                        y += this._drag_delta_y * __sin((y - min_y) / (this._height * this._drag_rate) * 1.57);
                        if (y < min_y)
                        {
                            y = min_y;
                            loop_end = true;
                        }
                    }
                    else
                        y += this._drag_delta_y;

                    if (y <= max_y && !this._open_extends_drag)
                        y = max_y;
                }
                this._scroll_linear.y = y;
                if (this._scroll_bar != null)
                    this._scroll_bar.offset_rate = -y / (linear_height - this._height);
            }
            this.RefreshClipDisLine();
        }
    
        if (this._drag_delta_y < 0)
        {
            this._drag_delta_y = this._drag_delta_y + 1;
            if (this._drag_delta_y >= 0)
                loop_end = true;
        }
        elseif (this._drag_delta_y > 0)
        {
            this._drag_delta_y = this._drag_delta_y - 1;
            if (this._drag_delta_y <= 0)
                loop_end = true;
        }
        else
        {
            loop_end = true;
        }
    
        // 惯性拖动结束
        if (loop_end)
        {
            A_LoopSystem.RemoveUpdater(this._drag_delta_loop_y);
    
            if (this._scroll_linear.y > 0)
            {
                var func = bind(ScrollList.RefreshClipDisLine, this, null);
                A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                this._drag_loop_y = new LoopLinear(this._scroll_linear, "y", 0, 200, 0, func);
                A_LoopSystem.AddUpdater(this._drag_loop_y);
    
                if (this._scroll_linear.y >= this._height * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragDownEvent());
                }
            }
            elseif (this._scroll_linear.y < -linear_height + this._height)
            {
                if (this._scroll_linear.y < 0)
                {
                    var func = bind(ScrollList.RefreshClipDisLine, this, null);
                    A_LoopSystem.RemoveUpdater(this._drag_loop_y);
                    this._drag_loop_y = new LoopLinear(this._scroll_linear, "y", -linear_height + this._height, 200, 0, func);
                    A_LoopSystem.AddUpdater(this._drag_loop_y);
                }
    
                if (this._scroll_linear.y <= -linear_height + this._height - this._height * this._drag_rate * 0.9)
                {
                    this.DispatchEvent(new UIDragUpEvent());
                }
            }
            this.HideRightScrollBar();
        }
    }
    
    // y轴滚动条位置回调
    protected fun YScrollBarChange()
    {
        this._scroll_bar.offset_rate = -this._scroll_linear.y / (this._linear_height - this._height);
    }
    // x轴滚动条位置回调
    protected fun XScrollBarChange()
    {
        this._scroll_bar.offset_rate = -this._scroll_linear.x / (this._linear_width - this._width);
    }
    
    //////////////////////////////////////////////////////////////////////////////
    protected fun RefreshClipDisLineImpl(double v_move)
    {
        this._scroll_linear.ClipRect(0, 0, this.width, this.height, null, v_move);
        this._clip_loop = null;
    }
    
    // 更新裁剪控件索引范围
    public fun RefreshClipDisLine([Nullable] double v_move)
    {
        this.UpdateLoadingShow();
        if (this._clip_atonce)
        {
            this._scroll_linear.ClipRect(0, 0, this.width, this.height, null, null);
            return;
        }
    
        if (this._clip_loop != null && this._clip_loop._user_data == null)
            return;

        this._clip_loop = new LoopFunction(bind(this.RefreshClipDisLineImpl, this, v_move), 1, 0, 1);
        this._clip_loop._user_data = v_move;
        A_LoopSystem.AddUpdater(this._clip_loop);
    }
    
    // 开始隐藏滚动条
    public fun HideRightScrollBar()
    {
        // 返回动画结束后，开始滚动条消失
        if (this._scroll_bar != null)
        {
            this._scroll_bar_loop = new LoopList();
            this._scroll_bar_loop.AddUpdater(new LoopLinear(this._scroll_bar, "alpha", 0, 2000, 1000));
            this._scroll_bar_loop.AddUpdater(new LoopAttribute(this._scroll_bar, "visible", false, 1));
            A_LoopSystem.AddUpdater(this._scroll_bar_loop);
        }
    }
    
    // 显示滚动条
    public fun ShowRightScrollBar()
    {
        if (this._scroll_bar_loop != null)
        {
            A_LoopSystem.RemoveUpdater(this._scroll_bar_loop);
            this._scroll_bar_loop = null;
    
            if (this._scroll_bar != null)
            {
                this._scroll_bar.visible = true;
                this._scroll_bar.alpha = 1;
            }
        }
    }
}