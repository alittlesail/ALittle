
namespace AUIPlugin;

private var List_Insert = ALittle.List_Insert;
private var List_Splice = ALittle.List_Splice;

public class AUICodeEdit : ALittle.DisplayLayout
{
    private AUICodeLanguage _language;  // 代码解析器

    private bool _editable = true;	// 标记是否可编辑

    // 查询快捷信息
    private int _query_info_version;
    private lua.ABnfQueryInfo _query_info;
    private bool _in_query_info = false;

    // 查询错误信息
    private ALittle.LoopTimer _error_loop;  // 显示错误信息的定时器
    private Map<AUICodeErrorInfo, bool> _error_map;    // 错误列表
    private ALittle.DisplayObject _error_btn;	// 错误按钮

    // 全文查找
    private ALittle.Dialog _find_dialog;        // 查找对话框
    private ALittle.ImageInput _find_input;  // 输入框
    private List<string> _find_text;		// 查找文本
    private Map<AUICodeFindInfo, ALittle.DisplayObject> _find_map; // 查找列表
    private ALittle.DisplayLayout _find_quad_container;// 查找提示

    // 跳转到行
    private ALittle.Dialog _gotoline_dialog;	// 跳转对话框
    private ALittle.ImageInput _gotoline_input;	// 跳转输入框

    private ALittle.ScrollScreen _code_screen;  // 滚动屏幕
	private AUICodeLinear _code_linear;      // 代码容器
    private ALittle.DisplayLayout _cursor_container;    // 光标容器
    private AUICodeQuad _edit_quad;           // 编辑区
    private ALittle.DisplayObject _goto_quad;   // goto的下划线
    private bool _move_in = false;			// 是否移入编辑区
    private ALittle.Linear _line_number;		// 行号

    // 光标
    protected AUICodeCursor _cursor;
    protected AUICodeSelectCursor _select_cursor;

    // 行信息
    private List<AUICodeLineInfo> _line_list = new List<AUICodeLineInfo>();
    private int _line_count = 0;

    // 用于计算文本
    private ALittle.Text _text_show;

    // 因为是等宽，所以可以事先计算一下字体宽度
    private double _ascii_width;    // ascii的宽度
    private double _word_width;     // 中文的宽度

    // 文件路径
    private string _file_path;
	private ALittle.RevokeList _revoke_list;         // 撤销操作列表

    // 记录当前ErrorQuad
    private ALittle.DisplayObject _error_quad_move_in;
    private bool _in_drag = false;
    private bool _force_query_error = false;

    // 断点信息
    private Map<int, bool> _break_points;

    // 帮助层
    private ALittle.DisplayLayout _help_container;
    private AUICodeCompleteScreen _complete_screen;
    private AUICodeParamList _param_dialog;

    public static Create() : AUICodeEdit { return g_Control.CreateControl{AUICodeEdit}("code_tab_screen"); }

    public ctor(ALittle.ControlSystem ctrl_sys)
    {
        // 创建提示滚动屏
        this._complete_screen = new AUICodeCompleteScreen(this);
        // 创建函数提示
        this._param_dialog = new AUICodeParamList(this);
    }

	public fun TCtor()
	{
        this._code_screen.AddEventListener(this, this.HandleFocusIn);
        this._code_screen.AddEventListener(this, this.HandleFocusOut);
        this._code_screen.AddEventListener(this, this.HandleMoveIn);
        this._code_screen.AddEventListener(this, this.HandleMoveOut);
        this._code_screen.AddEventListener(this, this.HandleLButtonDown);
        this._code_screen.AddEventListener(this, this.HandleDragBegin);
        this._code_screen.AddEventListener(this, this.HandleDrag);
        this._code_screen.AddEventListener(this, this.HandleDragEnd);
        this._code_screen.AddEventListener(this, this.HandleKeyDown);
        this._code_screen.AddEventListener(this, this.HandleKeyUp);
        this._code_screen.AddEventListener(this, this.HandleTextInput);
        this._code_screen.AddEventListener(this, this.HandleMouseMove);
        this._code_screen.AddEventListener(this, this.HandleDropFile);
        this._code_screen.EnableDrag(false);
        this.AddEventListener(this, this.HandleChangedEvent);

        this._find_dialog.visible = false;
        this._find_dialog.close_callback = bind(this.HandleFindDialogClose, this);

        this._gotoline_dialog.visible = false;

        this._error_btn.visible = false;
        
		// 创建编辑容器
        this._code_screen.container = new AUICodeEditContainer(this._ctrl_sys);
        this._edit_quad._user_data = this;
        this._goto_quad.visible = false;
        this._code_screen.container._user_data = this._code_linear;
        this._line_number = new ALittle.Linear(this._ctrl_sys);
        this._line_number.type = ALittle.UIEnumTypes.TYPE_V;
        this._line_number.width = CODE_LINE_NUMBER_WIDTH;
        this._code_screen.static_object_v = this._line_number;

        this._cursor = new AUICodeCursor(this._ctrl_sys, this);
        this._cursor.width = 1;
        this._cursor.height = CODE_LINE_HEIGHT;
        this._cursor_container.AddChild(this._cursor);
        this._cursor.disabled = true;
        this._cursor.Hide();

        this._select_cursor = new AUICodeSelectCursor(this);
        
        this._text_show = new ALittle.Text(this._ctrl_sys);
        this._text_show.font_path = CODE_FONT_PATH;
        this._text_show.font_size = CODE_FONT_SIZE;

        this._ascii_width = this._text_show.native_show.CalcTextWidth("A");
        this._word_width = this._text_show.native_show.CalcTextWidth("测");
    }

    public get is_input() : bool { return true; }
    public get editable() : bool { return this._editable; }
    public set editable(bool value) { this._editable = value; this._edit_quad.editable = value; }
    public get cursor_x() : double { return this._edit_quad.cursor_x; }
    public get cursor_y() : double { return this._edit_quad.cursor_y; }
    public get cursor_b() : double { return this._edit_quad.cursor_b; }

    public get code_screen() : ALittle.ScrollScreen { return this._code_screen; }
    public get code_linear() : AUICodeLinear { return this._code_linear; }
    public get cursor() : AUICodeCursor { return this._cursor; }
    public get select_cursor() : AUICodeSelectCursor { return this._select_cursor; }
    public get language() : AUICodeLanguage { return this._language; }
    public get ascii_width() : double { return this._ascii_width; }
    public get word_width() : double { return this._word_width; }
    public set line_count(int count) { this._line_count = count; }
    public get line_count() : int { return this._line_count; }
    public get line_list() : List<AUICodeLineInfo> { return this._line_list; }
    public get revoke_list() : ALittle.RevokeList { return this._revoke_list; }
    public get help_container() : ALittle.DisplayLayout { return this._help_container; }

    private fun DispatchJumpEvent()
    {
        var event = new AUICodeEditJumpEvent();
        event.file_path = this._file_path;
        event.it_line = this._cursor.line;
        event.it_char = this._cursor.char;
        this.DispatchEvent(event);
    }

    public get file_path() : string { return this._file_path; }

    public fun GetBreakPoint(int line_number) : bool
    {
        if (this._break_points == null) return false;
        return this._break_points[line_number];
    }
    public fun AddBreakPoint(int line_number)
    {
        if (this._break_points == null) this._break_points = new Map<int, bool>();
        this._break_points[line_number] = true;

        var break_event = new AUICodeEditBreakPointEvent();
        break_event.file_path = this._file_path;
        break_event.file_line = line_number;
        break_event.add_or_remove = true;
        this.DispatchEvent(break_event);
    }
    public fun RemoveBreakPoint(int line_number)
    {
        if (this._break_points == null) this._break_points = new Map<int, bool>();
        this._break_points[line_number] = false;

        var break_event = new AUICodeEditBreakPointEvent();
        break_event.file_path = this._file_path;
        break_event.file_line = line_number;
        break_event.add_or_remove = false;
        this.DispatchEvent(break_event);
    }

    public fun FocusLineCharToCenter(int it_line, int it_char) : bool
    {
        var line = this._line_list[it_line];
        if (line == null) return false;
        var char = line.char_list[it_char];
        if (char == null) char = line.char_list[1];
        if (char == null) return false;

        var y = (it_line - 1) * CODE_LINE_HEIGHT;
        var x = char.pre_width;
   
        var real_width = this._code_screen.container.width - this._code_screen.view_width;
        if (real_width > 0)
        {
            if (this._cursor.x <= -this._code_screen.container_x || this._cursor.x >= -this._code_screen.container_x + this._code_screen.view_width)
            {
                var view_x = this._code_screen.view_width / 2;
                var center_x = x;
                this._code_screen.bottom_scrollbar.offset_rate = (center_x - view_x) / real_width;
            }
        }

        var real_height = this._code_screen.container.height - this._code_screen.view_height;
        if (real_height > 0)
        {
            if (this._cursor.y <= -this._code_screen.container_y || this._cursor.y + CODE_LINE_HEIGHT >= -this._code_screen.container_y + this._code_screen.view_height)
            {
                var view_y = this._code_screen.view_height / 2;
                var center_y = y;
                this._code_screen.right_scrollbar.offset_rate = (center_y - view_y) / real_height;
            }
        }
        this._code_screen.AdjustScrollBar();

        return true;
    }

    public fun FocusLineCharToUp(int it_line, int it_char)
    {
        var line = this._line_list[it_line];
        if (line == null) return;

        var real_height = this._code_screen.container.height - this._code_screen.view_height;
        if (real_height > 0)
        {
            this._code_screen.right_scrollbar.offset_rate = (it_line - 1) * CODE_LINE_HEIGHT / real_height;
            this._code_screen.AdjustScrollBar();   
        }
    }

    public fun FocusLineCharToDown(int it_line, int it_char)
    {
        var line = this._line_list[it_line];
        if (line == null) return;

        var real_height = this._code_screen.container.height - this._code_screen.view_height;
        if (real_height > 0)
        {
            this._code_screen.right_scrollbar.offset_rate = (it_line * CODE_LINE_HEIGHT - this._code_screen.view_height) / real_height;
            this._code_screen.AdjustScrollBar();   
        }
    }

    private fun HandleFocusIn(ALittle.UIFocusInEvent event)
    {
        ALittle.System_OpenIME();
        this._cursor.Show();
    }

    private fun HandleFocusOut(ALittle.UIFocusOutEvent event)
    {
        ALittle.System_CloseIME();
        this._cursor.Hide();
    }

    private fun HandleMoveIn(ALittle.UIMoveInEvent event)
    {
        this._move_in = true;
        ALittle.System_SetEditCursor();
    }

    private fun HandleMoveOut(ALittle.UIMoveOutEvent event)
    {
        this.StopQueryInfo();
        this._move_in = false;
        ALittle.System_SetNormalCursor();
    }
    
    private fun HandleLButtonDown(ALittle.UILButtonDownEvent event)
    {
        var rel_x = event.rel_x;
        var rel_y = event.rel_y;
        if (event.target == this._code_screen)
        {
            rel_x -= this._code_linear.x;
            rel_y -= this._code_screen.container_y;
        } 

        // 如果有按下Shit键，那么就是范围选择
        if (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_LSHIFT] || A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_RSHIFT])
        {
            this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
            this._cursor.SetOffsetXY(rel_x, rel_y);
            this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);
        }
        else
        {
            this._select_cursor.Hide();
            this._cursor.SetOffsetXY(rel_x, rel_y);
        }
        
        // 如果多次点击，那么就选中文本
        if (event.count > 1)
        {
            var it_start, it_end = this._cursor.CalcSelectWord();
            if (it_start == null) return;
            this._cursor.SetLineChar(this._cursor.line, it_end);
            this._select_cursor.StartLineChar(this._cursor.line, it_start);
            this._select_cursor.UpdateLineChar(this._cursor.line, it_end);
        }

        if (A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_CTRL] && this._query_info != null && this._language != null)
        {
            var it_line, it_char = this.CalcLineAndChar(rel_x, rel_y);
            this.DoQueryGoto(it_line, it_char);
            this.StopQueryInfo();
        }

        this._complete_screen.TryHide();
        this._param_dialog.TryHide();
        this._cursor.AdjustShowCursor();
        this.DispatchJumpEvent();
    }

    private async fun DoQueryGoto(int it_line, int it_char)
    {
        var info = this._language.QueryGoto(it_line, it_char);
        if (info != null)
        {
            if (info.file_path == this._file_path)
            {
                this._cursor.SetLineChar(info.line_start, info.char_start - 1);
                this._select_cursor.StartLineChar(info.line_start, info.char_start - 1);
                this._select_cursor.UpdateLineChar(info.line_end, info.char_end);
                this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
                this.DispatchJumpEvent();
            }
            // 对外发送事件，让外面打开，然后再聚焦到某个代码段
            else
            {
                var goto_event = new AUICodeEditGotoEvent();
                goto_event.file_path = info.file_path;
                goto_event.line_start = info.line_start;
                goto_event.char_start = info.char_start;
                goto_event.line_end = info.line_end;
                goto_event.char_end = info.char_end;
                this.DispatchEvent(goto_event);
            }
        }
    }

    private fun HandleDragBegin(ALittle.UIButtonDragBeginEvent event)
    {
        if (this._error_quad_move_in != null)
        {
            g_AUITool.HideTip();
            this._error_quad_move_in = null;
        }

        var rel_x = event.rel_x;
        var rel_y = event.rel_y;
        if (event.target == this._code_screen)
        {
            rel_x -= this._code_linear.x;
            rel_y -= this._code_screen.container_y;
        }

        this._in_drag = true;
        this._cursor.SetOffsetXY(rel_x, rel_y);
        this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
    }

    private fun HandleDrag(ALittle.UIButtonDragEvent event)
    {

        var rel_x = event.rel_x;
        var rel_y = event.rel_y;
        if (event.target == this._code_screen)
        {
            rel_x -= this._code_linear.x;
            rel_y -= this._code_screen.container_y;
        }

        this._cursor.SetOffsetXY(rel_x, rel_y);
        this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);
    }

    private fun HandleDragEnd(ALittle.UIButtonDragEndEvent event)
    {
        this._select_cursor.TryHide();
        this._in_drag = false;
    }

    private fun HandleMouseMove(ALittle.UIMouseMoveEvent event)
    {
        var rel_x = event.rel_x;
        if (event.target == this._code_screen) rel_x -= this._code_linear.x;

        // 显示错误的TIP
        if (!this._in_drag)
        {
            // 获取是那一行
            var it_line = ALittle.Math_Floor(event.rel_y / CODE_LINE_HEIGHT) + 1;
            var line = this._line_list[it_line];
            if (line != null)
            {
                var rel_y = event.rel_y - (it_line - 1) * CODE_LINE_HEIGHT;
                var item = line.container._error.PickUp(rel_x, rel_y);
                if (item != this._error_quad_move_in)
                {
                    if (this._error_quad_move_in != null) g_AUITool.HideTip();
                    this._error_quad_move_in = item;
                    if (item != null)
                    {
                        var info = cast<lua.ABnfQueryError>(item._user_data);
                        var x, y = item.LocalToGlobal();
                        var center_x = x + item.width / 2;
                        var center_y = y;
                        g_AUITool.ShowTip(info.error);
                        var tip_width, tip_height = g_AUITool.GetTipSize();
                        g_AUITool.MoveTip(center_x - tip_width / 2, center_y - tip_height);
                    }
                }    
            }  
        }

        if (!A_UISystem.sym_map[ALittle.UIEnumTypes.KEY_CTRL]) return;

        this.UpdateQueryInfo(rel_x, event.rel_y);
    }

    private fun HandleDropFile(ALittle.UIDropFileEvent event)
    {
        var goto_event = new AUICodeEditGotoEvent();
        goto_event.file_path = event.path;
        this.DispatchEvent(goto_event);
    }

    public fun UpdateLineNumber()
    {
        var child_count = this._line_count + CODE_PAD_LINES;
        var delta = this._line_number.child_count - child_count;
        if (delta >= 0 && delta <= 10) return;

        if (delta > 0)
        {
            this._line_number.SpliceChild(child_count);
            return;
        }

        for (var index = this._line_number.child_count + 1; index <= child_count; 1)
        {
            var text = new AUICodeLineNumber(this._ctrl_sys, CODE_FONT_PATH, CODE_FONT_SIZE, this._ascii_width, this._word_width, this);
            text.height = CODE_LINE_HEIGHT;
            text.red = CODE_LINE_NUMBER_RED;
            text.green = CODE_LINE_NUMBER_GREEN;
            text.blue = CODE_LINE_NUMBER_BLUE;
            text.SetLineNumber(index);
            this._line_number.AddChild(text);
        }
    }

    private async fun UpdateQueryInfo(double x, double y)
    {
        if (this._language == null)
        {
            ALittle.System_SetEditCursor();
            return;
        }

        if (this._in_query_info)
        {
            if (this._query_info == null)
                ALittle.System_SetEditCursor();
            else
                ALittle.System_SetHandCursor();
            return;
        }

        var it_line, it_char = this.CalcLineAndChar(x, y);
        this._in_query_info = true;
        var info = this._language.QueryInfo(it_line, it_char);
        if (this._in_query_info == false || info == null)
        {
            if (this._query_info != null)
            {
                g_AUITool.HideTip();
                this._goto_quad.visible = false;
                var line_container = cast<AUICodeLineContainer>(this._code_linear.GetChildByIndex(this._query_info.line_start));
                if (line_container != null) line_container.RestoreColor();
                this._query_info = null;
            }
            ALittle.System_SetEditCursor();
            return;
        }
        this._in_query_info = false;

        if (this._query_info != null
            && this._query_info.line_start == info.line_start
            && this._query_info.char_start == info.char_start
            && this._query_info.line_end == info.line_end
            && this._query_info.char_end == info.char_end
            && this._query_info_version == this._language.version)
        {
            ALittle.System_SetHandCursor();
            return;
        }

        if (this._query_info != null)
        {
            g_AUITool.HideTip();
            this._goto_quad.visible = false;
            var line_container = cast<AUICodeLineContainer>(this._code_linear.GetChildByIndex(this._query_info.line_start));
            if (line_container != null) line_container.RestoreColor();   
            this._query_info = null;
        }

        var line = this._line_list[info.line_start];

        var quad_x, quad_y = this._edit_quad.LocalToGlobal();
        var char_end = info.char_end;
        if (line != null && info.line_start != info.line_end) info.char_end = line.char_count;
        var rect_x, rect_y, rect_width = this.CalcRect(info.line_start, info.char_start, char_end);

        // 如果这个时候鼠标已经移走，那么就清空
        if (A_UISystem.mouse_x < quad_x + rect_x || A_UISystem.mouse_x >= quad_x + rect_x + rect_width
            || A_UISystem.mouse_y < quad_y + rect_y || A_UISystem.mouse_y >= quad_y + rect_y + CODE_LINE_HEIGHT)
        {
            ALittle.System_SetEditCursor();
            return;
        }

        this._query_info_version = this._language.version;
        this._query_info = info;

        var line_container = cast<AUICodeLineContainer>(this._code_linear.GetChildByIndex(info.line_start));
        if (line != null && line_container != null)
        {
            if (info.line_start == info.line_end)
                line_container.SetColor(info.char_start, info.char_end, CODE_FOCUS_RED, CODE_FOCUS_GREEN, CODE_FOCUS_BLUE);
            else
                line_container.SetColor(info.char_start, line.char_count, CODE_FOCUS_RED, CODE_FOCUS_GREEN, CODE_FOCUS_BLUE);
        }

        g_AUITool.ShowTip(info.info);
        
        var center_x = rect_x + rect_width / 2 + quad_x;
        var center_y = rect_y + quad_y;
        var tip_width, tip_height = g_AUITool.GetTipSize();
        
        // 把内容放在头部
        g_AUITool.MoveTip(center_x - tip_width / 2, center_y - tip_height);

        this._goto_quad.x = rect_x;
        this._goto_quad.y = rect_y;
        this._goto_quad.width = rect_width;
        this._goto_quad.height = CODE_LINE_HEIGHT;
        this._goto_quad.visible = true;

        ALittle.System_SetHandCursor();
    }

    private fun StopQueryInfo()
    {
        if (this._language == null) return;
        this._in_query_info = false;

        this._query_info_version = null;

        if (this._query_info != null)
        {
            var line_container = cast<AUICodeLineContainer>(this._code_linear.GetChildByIndex(this._query_info.line_start));
            if (line_container != null) line_container.RestoreColor();
        }

        g_AUITool.HideTip();
        this._query_info = null;
        this._goto_quad.visible = false;
    }

    private async fun UpdateErrorInfo()
    {
        g_AUITool.HideTip();
        this._error_quad_move_in = null;
        if (this._error_map != null)
        {
            for (var info, _ in this._error_map)
                info.item.RemoveFromParent();
        }
        this._error_map = null;
        var list = this._language.QueryError(this._force_query_error);
        if (list == null)
        {
            this._error_btn.visible = false;
            return;
        }

        this._error_map = new Map<AUICodeErrorInfo, bool>();
        var error_count = 0;
        for (var index, info in list)
        {
            var item_info = new AUICodeErrorInfo();
            var item = g_Control.CreateControl{ALittle.DisplayObject}("code_error_item", item_info);
            var line = this._line_list[info.line_start];
            var char_end = info.char_end;
            if (info.line_start != info.line_end) info.char_end = line.char_count;
            item_info.info = info;
            var x, y, width = this.CalcRect(info.line_start, info.char_start, char_end);
            if (width <= 0) width = this._ascii_width;
            item.x = x;
            item.width = width;
            item.height = CODE_LINE_HEIGHT;
            item_info._focus_quad._user_data = info;
            item_info.item = item;
            item_info.info = info;
            item._user_data = info;
            line.container._error.AddChild(item);
            error_count += 1;
            this._error_map[item_info] = true;
        }
        this._error_btn.visible = error_count > 0;
    }

    private fun HandleErrorNextClick(ALittle.UIClickEvent event)
    {
        if (this.ErrorNextImpl(this._cursor.line, true)) return;
        this.ErrorNextImpl(1, false);
    }

    private fun ErrorNextImpl(int start_line, bool check_cursor) : bool
    {
        var line_index = start_line;
        while (line_index <= this._line_count)
        {
            var line = this._line_list[line_index];
            for (var index, child in line.container._error.childs)
            {
                var info = cast<lua.ABnfQueryError>(child._user_data);
                if (!check_cursor || line_index != this._cursor.line || info.char_start > this._cursor.char + 1)
                {
                    this.EditFocus(info.line_start, info.char_start, null, null, false);
                    return true;
                }
            }

            line_index += 1;
        }

        return false;
    }

    public fun SetFindInput(string text)
    {
        this._find_input.text = text;
        this.HandleFindInputChanged(null);
    }

    private fun HandleFindInputChanged(ALittle.UIChangedEvent event)
    {
        this.ClearFindInfo();

        var content = this._find_input.text;
        this._find_text = ALittle.String_SplitUTF8(content);
        var find_len = ALittle.List_Len(this._find_text);
        if (find_len == 0) return;

        this._find_map = new Map<AUICodeFindInfo, ALittle.DisplayObject>();
        this._find_quad_container.RemoveAllChild();
        var has_find = false;
        for (var index, line in this._line_list)
        {
            if (line.char_count >= find_len)
            {
                var char_index = 1;
                while (char_index <= line.char_count)
                {
                    var find = true;
                    for (var i, char in this._find_text)
                    {
                        if (char != line.char_list[char_index + i - 1].char)
                        {
                            find = false;
                            break;
                        }
                    }

                    if (find)
                    {
                        var item = new ALittle.Quad(g_Control);
                        item.red = CODE_FIND_RED;
                        item.green = CODE_FIND_GREEN;
                        item.blue = CODE_FIND_BLUE;
                        item.x = line.char_list[char_index].pre_width;
                        item.width = line.char_list[char_index + find_len].pre_width - line.char_list[char_index].pre_width;
                        item.height = CODE_LINE_HEIGHT;
                        line.container._find.AddChild(item);
                        var info = new AUICodeFindInfo();
                        info._focus_quad = item;
                        info.it_char_start = char_index;
                        info.it_char_end = char_index + find_len - 1;
                        item._user_data = info;

                        var highlight_quad = new ALittle.Quad(g_Control);
                        highlight_quad.width_type = ALittle.UIEnumTypes.SIZE_MARGIN;
                        highlight_quad.height = 2;
                        highlight_quad.red = CODE_FIND_RED;
                        highlight_quad.green = CODE_FIND_GREEN;
                        highlight_quad.blue = CODE_FIND_BLUE;
                        highlight_quad.y = (index - 1) / this.line_count * this._find_quad_container.height;
                        this._find_quad_container.AddChild(highlight_quad);
                        this._find_map[info] = highlight_quad;
                        char_index += find_len;

                        has_find = true;
                    }
                    else
                    {
                        char_index += 1;
                    }
                }   
            }
        }

        if (has_find) this.FindNextImpl(this._cursor.line, true);
    }

    private fun HandleFindNextClick(ALittle.UIClickEvent event)
    {
        this.FindNext(null);
    }

    public fun FindNext(string content)
    {
        if (content != null && this._find_input.text != content)
        {
            this.SetFindInput(content);
            return;
        }
        if (this.FindNextImpl(this._cursor.line, true)) return;
        this.FindNextImpl(1, false);
    }

    private fun FindNextImpl(int start_line, bool check_cursor) : bool
    {
        var line_index = start_line;
        while (line_index <= this._line_count)
        {
            var line = this._line_list[line_index];
            for (var index, child in line.container._find.childs)
            {
                var info = cast<AUICodeFindInfo>(child._user_data);
                if (!check_cursor || line_index != this._cursor.line || info.it_char_start > this._cursor.char + 1)
                {
                    this.EditFocus(line_index, info.it_char_start, line_index, info.it_char_end, false);
                    return true;
                }
            }

            line_index += 1;
        }

        return false;
    }

    private fun HandleGotoLineClick(ALittle.UIClickEvent evnet)
    {
        var number = ALittle.Math_ToInt(this._gotoline_input.text);
        if (number == null) return;

        if (number > this._line_count) number = this._line_count;
        this.EditFocus(number, 1, null, null, true);

        this._gotoline_dialog.visible = false;
    }

    private fun HandleGotoLineEscClick(ALittle.UIEvent event)
    {
        this._gotoline_dialog.visible = false;
    }

    public fun UpdateLineFind(int it_line)
    {
        if (this._find_map == null) return;

        // 删除当前行
        var line = this._line_list[it_line];
        if (line == null) return;

        for (var index, child in line.container._find.childs)
        {
            var quad = this._find_map[child._user_data];
            this._find_map[child._user_data] = null;
            if (quad != null) this._find_quad_container.RemoveChild(quad);
        }
        line.container._find.RemoveAllChild();

        // 重新计算
        var find_len = ALittle.List_Len(this._find_text);
        if (find_len == 0) return;

        if (line.char_count < find_len) return;

        var char_index = 1;
        while (char_index <= line.char_count)
        {
            var find = true;
            for (var i, char in this._find_text)
            {
                if (char != line.char_list[char_index + i - 1].char)
                {
                    find = false;
                    break;
                }
            }

            if (find)
            {
                var item = new ALittle.Quad(g_Control);
                item.red = CODE_FIND_RED;
                item.green = CODE_FIND_GREEN;
                item.blue = CODE_FIND_BLUE;
                item.x = line.char_list[char_index].pre_width;
                item.width = line.char_list[char_index + find_len].pre_width - line.char_list[char_index].pre_width;
                item.height = CODE_LINE_HEIGHT;
                line.container._find.AddChild(item);
                var info = new AUICodeFindInfo();
                info._focus_quad = item;
                info.it_char_start = char_index;
                info.it_char_end = char_index + find_len - 1;
                item._user_data = info;

                var highlight_quad = new ALittle.Quad(g_Control);
                highlight_quad.width_type = ALittle.UIEnumTypes.SIZE_MARGIN;
                highlight_quad.height = 2;
                highlight_quad.red = CODE_FIND_RED;
                highlight_quad.green = CODE_FIND_GREEN;
                highlight_quad.blue = CODE_FIND_BLUE;
                highlight_quad.y = (it_line - 1) / this.line_count * this._find_quad_container.height;
                this._find_quad_container.AddChild(highlight_quad);
                this._find_map[info] = highlight_quad;
                char_index += find_len;
            }
            else
            {
                char_index += 1;
            }
        }   
    }

    private fun HandleFindDialogClose() : bool
    {
        this.HandleFindEscClick(null);
        return true;
    }

    private fun HandleFindEscClick(ALittle.UIEvent event)
    {
        this._find_dialog.visible = false;
        this.ClearFindInfo();
    }

    public fun ClearFindInfo()
    {
        if (this._find_map != null)
        {
            for (var info, _ in this._find_map)
                info._focus_quad.RemoveFromParent();
        }
        this._find_quad_container.RemoveAllChild();
        this._find_map = null;
    }

    private fun HandleChangedEvent(ALittle.UIChangedEvent event)
    {
        if (this._language == null) return;

        // 获取显示的行，然后进行颜色处理
        var map = this._code_linear.GetShowMap();
        for (var object:AUICodeLineContainer, _ in map)
            object.RestoreColor();

        this.StartErrorLoop(false);
    }

    private fun StartErrorLoop(bool force)
    {
        if (this._language == null) return;

        this._force_query_error = force;
        if (this._error_loop == null)
            this._error_loop = new ALittle.LoopTimer(bind(this.UpdateErrorInfo, this), 1000);

        this._error_loop.Stop();
        this._error_loop.Reset();
        this._error_loop.Start();        
    }

    // 计算行列
    public fun CalcLineAndChar(double x, double y) : int, int
    {
        var it_line = ALittle.Math_Floor(y / CODE_LINE_HEIGHT) + 1;
        if (it_line < 1) it_line = 1;
        elseif (it_line > this._line_count) it_line = this._line_count;

        var it_char:int = 0;
        var line = this._line_list[it_line];
        if (line == null) return it_line, it_char;
        if (line.char_count == 0) return it_line, 0;

        var pre_width = line.char_list[1].width / 2;
        if (x < line.char_list[1].width / 2) return it_line, 0;

        for (var index = 1; index < line.char_count; 1)
        {
            var next_width = pre_width + line.char_list[index].width / 2 + line.char_list[index + 1].width / 2;
            if (x >= pre_width && x < next_width)
                return it_line, index;
            pre_width = next_width;
        }
        var count = line.char_count;
        while (count > 0 && line.char_list[count].width <= 0)
            -- count;
        return it_line, count;
    }

    // 计算坐标，获取x，y，宽度
    public fun CalcRect(int it_line, int char_start, int char_end) : double, double, double
    {
        var line = this._line_list[it_line];
        if (line == null) return 0,0,0;

        var y = (it_line - 1) * CODE_LINE_HEIGHT;
        
        var x = 0.0;
        if (line.char_list[char_start] != null) x = line.char_list[char_start].pre_width;

        var width = 0.0;
        var char_e = line.char_list[char_end];
        if (char_e != null) width = char_e.pre_width + char_e.width - x;

        return x, y, width;
    }

    // 计算相对坐标
    public fun CalcPosition(int it_line, int it_char, bool pre) : double, double
    {
        var line = this._line_list[it_line];
        if (line == null) return 0, 0;

        var y = (it_line - 1) * CODE_LINE_HEIGHT;
        var x = 0.0;
        if (it_char > 0)
        {
            x = line.char_list[it_char].pre_width;
            if (!pre) x += line.char_list[it_char].width;
        }
            
        return x, y;
    }

    // 上色
    public fun BrushColor(int line_start, int char_start, int line_end, int char_end, double red, double green, double blue)
    {
        if (line_start == line_end)
        {
            var line = this._line_list[line_start];
            for (var it_char = char_start + 1; it_char <= char_end; 1)
            {
                var char = line.char_list[it_char];
                char.red = red; char.green = green; char.blue = blue;
                if (char.text != null) { char.text.red = red; char.text.green = green; char.text.blue = blue; }
            }
            return;
        }

        for (var it_line = line_start; it_line <= line_end; 1)
        {
            var line = this._line_list[it_line];
            if (it_line == line_start)
            {
                for (var it_char = char_start + 1; it_char <= line.char_count; 1)
                {
                    var char = line.char_list[it_char];
                    char.red = red; char.green = green; char.blue = blue;
                    if (char.text != null) { char.text.red = red; char.text.green = green; char.text.blue = blue; }
                }
            }
            elseif (it_line == line_end)
            {
                for (var it_char = 1; it_char <= char_end; 1)
                {
                    var char = line.char_list[it_char];
                    char.red = red; char.green = green; char.blue = blue;
                    if (char.text != null) { char.text.red = red; char.text.green = green; char.text.blue = blue; }
                }
            }
            else
            {
                for (var it_char = 1; it_char <= line.char_count; 1)
                {
                    var char = line.char_list[it_char];
                    char.red = red; char.green = green; char.blue = blue;
                    if (char.text != null) { char.text.red = red; char.text.green = green; char.text.blue = blue; }
                }
            }
        }
    }

    // 删除选择行
    public fun DeleteSelectText() : bool
    {
        var result, it_line, it_char = this._select_cursor.DeleteSelect(true);
        if (result) this._cursor.SetLineChar(it_line, it_char);
        return result;
    }

    private fun HandleTextInput(ALittle.UITextInputEvent event)
    {
        if (!this._editable) return;

        var text = this._cursor.virtual_indent..event.text;
        if (this.InsertText(text, true))
        {
            if (this._language != null)
            {
                var auto_pair = this._language.QueryAutoPair(this._cursor.line, this._cursor.char, event.text);
                if (auto_pair != null)
                {
                    if (this._cursor.GetNextCharInLine() != auto_pair)
                    {
                        var old_line = this._cursor.line;
                        var old_char = this._cursor.char;
                        this.InsertText(auto_pair, true);
                        this._cursor.SetLineChar(old_line, old_char);
                    }
                }
                elseif (this._language.QueryAutoFormat(event.text))
                {
                    this.MultiLineFormat(this._cursor.line, this._cursor.line);
                }
            }

            this.DispatchEvent(new ALittle.UIChangedEvent());

            if (text != " ")
            {
                if (text == ".")
                    this._complete_screen.Hide();
                this._complete_screen.ShowComplete();
            }
            else
            	this._complete_screen.Hide();
            this._param_dialog.ShowParamList();
        }   
    }

    private fun HandleKeyDown(ALittle.UIKeyDownEvent event)
    {
        // 标记是否需要发送CHANGE事件
        var is_change = false;
        // 处理键盘按键
        if (event.sym == ALittle.UIEnumTypes.KEY_LEFT)
        {
            if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT == 0)
            {
                if (this._select_cursor.line_start != null)
                {
                    var it_line, it_char = this._select_cursor.GetLineCharCloseToHome();
                    this._cursor.SetLineChar(it_line, it_char);
                    this._select_cursor.Hide();
                }
                else
                    this._cursor.OffsetLeft(event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0);
                this._cursor.AdjustShowCursor();
                this._complete_screen.TryHide();
                this._param_dialog.TryHide();
            }
            else
            {
                if (this._select_cursor.line_start == null)
                    this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
                this._cursor.OffsetLeft(event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0);
                if (this._cursor.line == this._select_cursor.line_start && this._cursor.char == this._select_cursor.char_start)
                    this._cursor.OffsetLeft(event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0);
                this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);
                this._complete_screen.Hide();
                this._param_dialog.Hide();
            }

			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_UP)
        {
            if (this._complete_screen.IsShow())
            {
                this._complete_screen.SelectUp();   
            }
            else
            {
                if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT == 0)
                {
                    if (this._select_cursor.line_start != null)
                    {
                        var it_line, it_char = this._select_cursor.GetLineCharCloseToHome();
                        this._cursor.SetLineChar(it_line, it_char);
                        this._select_cursor.Hide();
                    }
                    else
                        this._cursor.OffsetUp();
                    this._cursor.AdjustShowCursor();
                }
                else
                {
                    if (this._select_cursor.line_start == null)
                        this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
                    this._cursor.OffsetUp();
                    if (this._cursor.line == this._select_cursor.line_start && this._cursor.char == this._select_cursor.char_start)
                        this._cursor.OffsetUp();
                    this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);   
                }
                var offset_y = this._cursor.y + this._code_screen.container_y;
                if (offset_y < 0) this.FocusLineCharToUp(this._cursor.line, this._cursor.char);
                this._complete_screen.Hide();
                this._param_dialog.Hide();
            }
			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_DOWN)
        {
            if (this._complete_screen.IsShow())
            {
                this._complete_screen.SelectDown();   
            }
            else
            {
                if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT == 0)
                {
                    if (this._select_cursor.line_start != null)
                    {
                        var it_line, it_char = this._select_cursor.GetLineCharCloseToEnd();
                        this._cursor.SetLineChar(it_line, it_char);
                        this._select_cursor.Hide();
                    }
                    else
                        this._cursor.OffsetDown();
                    this._cursor.AdjustShowCursor();
                }
                else
                {
                    if (this._select_cursor.line_start == null)
                        this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
                    this._cursor.OffsetDown();
                    if (this._cursor.line == this._select_cursor.line_start && this._cursor.char == this._select_cursor.char_start)
                        this._cursor.OffsetDown();
                    this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);   
                }
                var offset_y = this._cursor.y + this._cursor.height + this._code_screen.container_y;
                if (offset_y > this._code_screen.view_height) this.FocusLineCharToDown(this._cursor.line, this._cursor.char);
                this._complete_screen.Hide();
                this._param_dialog.Hide();
            }
			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_RIGHT)
        {
            if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT == 0)
            {
                if (this._select_cursor.line_start != null)
                {
                    var it_line, it_char = this._select_cursor.GetLineCharCloseToEnd();
                    this._cursor.SetLineChar(it_line, it_char);
                    this._select_cursor.Hide();
                }
                else
                    this._cursor.OffsetRight(event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0);
                this._cursor.AdjustShowCursor();
                this._complete_screen.TryHide();
                this._param_dialog.TryHide();
            }
            else
            {
                if (this._select_cursor.line_start == null)
                    this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
                this._cursor.OffsetRight(event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0);
                if (this._cursor.line == this._select_cursor.line_start && this._cursor.char == this._select_cursor.char_start)
                    this._cursor.OffsetRight(event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0);
                this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);   
                this._complete_screen.Hide();
                this._param_dialog.Hide();
            }
			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_BACKSPACE)
        {
            if (this._editable)
            {
                if (this._select_cursor.line_start == null)
                {
                    is_change = this._cursor.DeleteLeft(true);
                    this._cursor.AdjustShowCursor();
                    this._complete_screen.TryHide();
                    if (this._complete_screen.IsShow())
                        this._complete_screen.ShowComplete();
                    this._param_dialog.TryHide();
                    if (this._param_dialog.IsShow())
                    	this._param_dialog.ShowParamList();
                }
                else
                {
                    is_change = this.DeleteSelectText();
                    this._complete_screen.Hide();
                    this._param_dialog.Hide();
                }
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_DELETE)
        {
            if (this._editable)
            {
                if (this._select_cursor.line_start == null)
                    is_change = this._cursor.DeleteRight(true);
                else
                    is_change = this.DeleteSelectText();
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_HOME)
        {
            if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT == 0)
            {
                if (this._select_cursor.line_start != null)
                {
                    var it_line, it_char = this._select_cursor.GetLineCharCloseToHome();
                    this._cursor.SetLineChar(it_line, it_char);
                    this._select_cursor.Hide();
                }
                else
                    this._cursor.OffsetHome();
                this._complete_screen.TryHide();
                this._param_dialog.TryHide();
            }
            else
            {
                if (this._select_cursor.line_start == null)
                    this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
                this._cursor.OffsetHome();
                this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);  
                this._complete_screen.Hide();
                this._param_dialog.Hide(); 
            }
            event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_END)
        {
            if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT == 0)
            {
                if (this._select_cursor.line_start != null)
                {
                    var it_line, it_char = this._select_cursor.GetLineCharCloseToEnd();
                    this._cursor.SetLineChar(it_line, it_char);
                    this._select_cursor.Hide();
                }
                else
                    this._cursor.OffsetEnd();
                this._complete_screen.TryHide();
                this._param_dialog.TryHide();
            }
            else
            {
                if (this._select_cursor.line_start == null)
                    this._select_cursor.StartLineChar(this._cursor.line, this._cursor.char);
                this._cursor.OffsetEnd();
                this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char); 
                this._complete_screen.Hide();
                this._param_dialog.Hide();
            }
			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_ENTER || event.sym == ALittle.UIEnumTypes.KEY_NUMBER_ENTER)
        {
            if (this._editable)
            {
                if (this._complete_screen.IsShow())
                {
                    is_change = this._complete_screen.DoSelect();
                }
                else
                {
                    var old_line = this._cursor.line;
                    var old_char = this._cursor.char;
                    var revoke_bind = new ALittle.RevokeBind();
                    is_change = this.InsertText("\n", true, revoke_bind);
                    if (this._cursor.CurLineHasChar())
                    {
                        this._cursor.UpdateVirtualIndent();
                        var text = this._cursor.virtual_indent;
                        if (text != "")
                            is_change = this.InsertText(text, true, revoke_bind);
                            // 如果右边是花括号
                        if (this._cursor.GetCurCharInLine() == "}")
                        {
                            this._cursor.SetLineChar(old_line, old_char);
                            is_change = this.InsertText("\n", true, revoke_bind);
                            this._cursor.AdjustShowCursor();
                        }
                    }
                    else
                        this._cursor.AdjustShowCursor();
                    revoke_bind.complete = bind(this.DispatchChangedEvent, this);
                    this._revoke_list.PushRevoke(revoke_bind);
                }
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_TAB)
        {
            if (this._editable)
            {
                if (this._select_cursor.line_start != this._select_cursor.line_end)
                {
                    if (event.mod & ALittle.UIEnumTypes.KMOD_SHIFT != 0)
                        is_change = this.MultiTabDelete(true);
                    else
                        is_change = this.MultiTabInsert(true);
                }
                else
                {
                    var text = this._cursor.virtual_indent.."\t";
                    is_change = this.InsertText(text, true);
                }
                this._complete_screen.Hide();
                this._param_dialog.Hide();
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_X && event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0)
        {
            if (this._editable)
            {
                var select_text = this._select_cursor.GetSelectText();
                if (select_text != null)
                    ALittle.System_SetClipboardText(select_text);
                is_change = this.DeleteSelectText();
                this._complete_screen.Hide();
                this._param_dialog.Hide();
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_C && event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0)
        {
            var select_text = this._select_cursor.GetSelectText();
            if (select_text != null)
                ALittle.System_SetClipboardText(select_text);
			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_V && event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0)
        {
            if (this._editable)
            {
                if (ALittle.System_HasClipboardText())
                {
                    var old_line = this._cursor.line;
                    is_change = this.InsertText(ALittle.System_GetClipboardText(), true);
                    var new_line = this._cursor.line;
                    this._complete_screen.Hide();
                    this._param_dialog.Hide();
                    this.MultiLineFormat(old_line, new_line);
                }
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_A && event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0)
        {
            if (this._line_count > 0)
            {
                this._cursor.SetLineChar(this._line_count, this._line_list[this._line_count].char_count);
                this._select_cursor.StartLineChar(1, 0);
                this._select_cursor.UpdateLineChar(this._cursor.line, this._cursor.char);
                this._complete_screen.Hide(); 
                this._param_dialog.Hide();  
            }
			event.handled = true;
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_F && event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0)
        {
            this._find_dialog.visible = true;
            this._find_input.DelayFocus();
            this._find_input.SelectAll();
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_G && event.mod & ALittle.UIEnumTypes.KMOD_CTRL != 0)
        {
            this._gotoline_dialog.visible = true;
            this._gotoline_input.DelayFocus();
            this._gotoline_input.SelectAll();
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_CTRL)
        {
            if (this._move_in && !this._in_query_info)
            {
                var x, y = this._edit_quad.LocalToGlobal();
                this.UpdateQueryInfo(A_UISystem.mouse_x - x, A_UISystem.mouse_y - y);
            }   
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_ESC)
        {
            if (this._find_dialog != null && this._find_dialog.visible)
            {
                this._find_dialog.visible = false;
                event.handled = true;
            }

            if (this._gotoline_dialog != null && this._gotoline_dialog.visible)
            {
                this._gotoline_dialog.visible = false;
                event.handled = true;
            }
        }
        elseif (event.sym == ALittle.UIEnumTypes.KEY_F12)
        {
            this.DoQueryGoto(this._cursor.line, this._cursor.char);
            this.StopQueryInfo();
            event.handled = true;
        }
        
        // 检查是否发送CHANGE事件
        if (is_change)
        {
            this.DispatchEvent(new ALittle.UIChangedEvent());
        }
    }

    private fun DispatchChangedEvent()
    {
        this.DispatchEvent(new ALittle.UIChangedEvent());
    }

    private fun HandleKeyUp(ALittle.UIKeyUpEvent event)
    {
        if (event.sym == ALittle.UIEnumTypes.KEY_CTRL)
        {
            if (this._move_in)
            {
                ALittle.System_SetEditCursor();
                this.StopQueryInfo();
            }
            else
                ALittle.System_SetNormalCursor();
        }
    }

    public fun OnUnDo()
    {
        this._complete_screen.Hide();
        this._param_dialog.Hide();
    }

    public fun OnTabRightMenu(AUIRightMenu menu)
    {
        if (this._language != null) this._language.OnTabRightMenu(menu);
    }

    public fun OnHide()
    {
        this._cursor.Hide();
        if (this._language != null) this._language.OnHide();
    }

    public fun OnShow()
    {
        this._edit_quad.DelayFocus();
        if (this._language != null) this._language.OnShow();
        this.StartErrorLoop(true);
    }

    public fun OnSave()
    {
        if (this._language != null) this._language.OnSave();
    }

    public fun OnClose()
    {
        if (this._error_loop != null)
        {
            this._error_loop.Stop();
            this._error_loop = null;
        }
        this._cursor.Hide();
        this._file_path = null;
        ALittle.System_CloseIME();

        if (this._language != null) this._language.OnClose();
    }

    public fun Load(string file_path, string content, ALittle.RevokeList revoke_list, [Nullable] AUICodeLanguage language, [Nullable] List<int> break_points) : bool
    {
        // 保存代码解析器
        this._language = language;

        // 保存断点信息
        if (break_points != null)
        {
            this._break_points = new Map<int, bool>();
            for (var index, value in break_points)
                this._break_points[value] = true;
        }

        var upper_ext = ALittle.File_GetFileExtByPathAndUpper(file_path);
        // 如果没有指定language，并且是abnf文件，那么就创建一个默认的
        if (this._language == null && upper_ext == "ABNF")
            this._language = new AUICodeABnf(null, file_path);
        if (this._language == null && AUICodeProject.SupportUpperExt(upper_ext))
            this._language = new AUICodeCommon(null, file_path);

        if (this._language != null) this._language.OnOpen(content);

        // 打开文件
        if (content == null)
        	content = ALittle.File_ReadTextFromStdFile(file_path);
        if (content == null) return false;

        // 设置文本内容
        this.SetText(content);
        this._file_path = file_path;
        this._revoke_list = revoke_list;
        if (this._revoke_list == null) this._revoke_list = new ALittle.RevokeList(10000);

        return true;
    }

    // 根据内容创建行
    private fun CreateLines(string content) : List<AUICodeLineInfo>, int, double
    {
        var line_list = new List<AUICodeLineInfo>();
        var line_count = 0;
        var max_width = 0.0;

        var line:AUICodeLineInfo = null;
        var len = ALittle.String_Len(content);
        var index = 1;
        var pre_width = 0.0;

        var UTF8ByteCount = carp.UTF8ByteCount;
        var sub = lua.String.sub;
        var ascii_width = this._ascii_width;
        var word_width = this._word_width;

        while (index <= len)
        {
            var is_asicc = true;
            var byte_count = 1;
            var char_text:string = null;
            [Language(Lua)]
            {
                byte_count = UTF8ByteCount(content, index - 1, 1);
                if (byte_count > 1) is_asicc = false;
                char_text = sub(content, index, index + byte_count - 1);
            }
            [Language(JavaScript)]
            {
                var code = cast<javascript.String>(content).charCodeAt(index - 1);
                if (code > 255) is_asicc = false;
                char_text = cast<javascript.String>(content).substring(index - 1, index);
            }
            index += byte_count;

            var char = new AUICodeCharInfo();
            if (is_asicc)
            {
                if (char_text == "\t")
                    char.width = ascii_width * 4;
                elseif (char_text == "\r" || char_text == "\n")
                    char.width = 0;
                else
                    char.width = ascii_width;
            }   
            else
                char.width = word_width;
            char.red = CODE_FONT_RED;
            char.green = CODE_FONT_GREEN;
            char.blue = CODE_FONT_BLUE;
            char.char = char_text;
            char.pre_width = pre_width;
            pre_width += char.width;

            if (line == null)
            {
                line = new AUICodeLineInfo();
                line.edit = this;
                line.char_count = 0;
                line.char_list = new List<AUICodeCharInfo>();
                line.container = new AUICodeLineContainer(g_Control);
                line.container._user_data = line;
                line.container.height = CODE_LINE_HEIGHT;
            }
            line.char_count += 1;
            line.char_list[line.char_count] = char;

            if (char_text == "\n")
            {
                line_count += 1;
                line_list[line_count] = line;
                line = null;
                pre_width = 0;
            }
        }

        if (line != null)
        {
            line_count += 1;
            line_list[line_count] = line;
        }

        var last_line = line_list[line_count];
        if (last_line == null) return line_list, line_count, max_width;
        var last_char = last_line.char_list[last_line.char_count];
        if (last_char == null) return line_list, line_count, max_width;

        // 如果最后一个是回车，那么加一个空行
        if (last_char.char == "\n")
        {
            line = new AUICodeLineInfo();
            line.edit = this;
            line.char_count = 0;
            line.char_list = new List<AUICodeCharInfo>();
            line.container = new AUICodeLineContainer(g_Control);
            line.container._user_data = line;
            line.container.height = CODE_LINE_HEIGHT;
            line_count += 1;
            line_list[line_count] = line;
        }

        for (var i, line_info in line_list)
        {
            last_char = line_info.char_list[line_info.char_count];
            if (last_char != null) line_info.container.width = last_char.pre_width + last_char.width;
            if (line_info.container.width > max_width) max_width = line_info.container.width;
        }

        return line_list, line_count, max_width;
    }

    // 设置文本
    public fun SetText(string content)
    {
        this._code_linear.RemoveAllChild();
        var max_width = 0.0;
        this._line_list, this._line_count, max_width = this.CreateLines(content);

        for (var index, line in this._line_list)
            this._code_linear.AddChild(line.container);
        this.AdjustCodeScreen(max_width);

        this._cursor.SetLineChar(1, 0);

        if (this._language != null) this._language.SetText(content);

		this.UpdateLineNumber();
    }

    // 更新代码窗口大小
    public fun AdjustCodeScreen(double max_width)
    {
        this._code_screen.container.width = max_width + CODE_LINE_NUMBER_WIDTH;
        this._code_screen.container.height = this._line_count * CODE_LINE_HEIGHT + CODE_PAD_LINES * CODE_LINE_HEIGHT;
        this._code_screen.AdjustScrollBar();
    }

    // 插入多行tab键
    public fun MultiTabInsert(bool need_revoke, [Nullable]ALittle.RevokeBind revoke_bind) : bool
    {
        var insert_revoke:ALittle.RevokeBind;
        if (need_revoke)
        {
            if (revoke_bind != null) insert_revoke = revoke_bind;
            else insert_revoke = new ALittle.RevokeBind();
        }

        if (this._select_cursor.line_start == null || this._select_cursor.line_end == null) return false;

        var old_line_start = this._select_cursor.line_start;
        var old_char_start = this._select_cursor.char_start;
        var old_line_end = this._select_cursor.line_end;
        var old_char_end = this._select_cursor.char_end;

        var old_line = this._cursor.line;
        var old_char = this._cursor.char;

        var line_min = this._select_cursor.line_start;
        var line_max = this._select_cursor.line_end;
        if (line_min > line_max)
        {
            var temp = line_min;
            line_min = line_max;
            line_max = temp;
        }

        for (var index = line_min; index <= line_max; 1) 
        {
        	if (this._language != null) this._language.InsertText("    ", index, 1);
            var line = this._line_list[index];
            for (var char_index, char in line.char_list)
            {
                char.pre_width += this._ascii_width * 4;
                if (char.text != null)
					char.text.x += this._ascii_width * 4;
            }
            line.container.width += this._ascii_width * 4;
            for (var i = 1; i <= 4; 1)
            {
                var char = new AUICodeCharInfo();
                char.pre_width = (i - 1) * this._ascii_width;
                char.char = " ";
                char.width = this._ascii_width;
                List_Insert(line.char_list, i, char);
            }
        	line.char_count += 4;
        }

        var max_width = 0.0;
        for (var index, line in this._line_list)
            if (line.container.width > max_width) max_width = line.container.width;
        this._code_screen.container.width = max_width + CODE_LINE_NUMBER_WIDTH;
        this._code_screen.AdjustScrollBar();

        this._cursor.SetLineChar(old_line, old_char + 4);
        this._select_cursor.StartLineChar(old_line_start, old_char_start + 4);
        this._select_cursor.UpdateLineChar(old_line_end, old_char_end + 4);

        if (this._find_map != null)
        {
            for (var index = line_min; index <= line_max; 1) 
                this.UpdateLineFind(index);
        }

        if (need_revoke)
        {
            var revoke = new AUICodeMultiTabInsertRevoke(this, this._cursor, this._select_cursor
            	, old_line_start, old_char_start, old_line_end, old_char_end
            	, this._select_cursor.line_start, this._select_cursor.char_start, this._select_cursor.line_end, this._select_cursor.char_end
            	, revoke_bind == null);
            insert_revoke.PushRevoke(revoke);
            if (revoke_bind == null)
                this._revoke_list.PushRevoke(insert_revoke);
        }
        return true;
    }

    // 行缩进格式化
    public fun MultiLineFormat(int line_start, int line_end)
    {
        if (this._language == null || !this._language.NeedAutoFormat()) return;

        if (line_start > line_end)
        {
            var temp = line_start;
            line_start = line_end;
            line_end = temp;
        }

        var old_line = this._cursor.line;
        var old_char = this._cursor.char;

        var revoke_bind = new ALittle.RevokeBind();

        var old_indent_list = new Map<int, int>();
        var indent_list = new Map<int, int>();
        var delete_list = new Map<int, int>();
        for (var index = line_start; index <= line_end; 1)
        {
            var line = this._line_list[index];
            var old_indent = 0;
            var delete_count = 0;
            for (var i, char in line.char_list)
            {
                if (char.char == " ")
                {
                	old_indent += 1;
                    delete_count += 1;
                }
                elseif (char.char == "\t")
                {
                	old_indent += 4;
                    delete_count += 1;
                }
                else
                {
					break;
                }
            }

            old_indent_list[index] = old_indent;
            delete_list[index] = delete_count;

            var first_char = line.char_list[1];
            if (first_char == null || first_char.char == "\r" || first_char.char == "\n")
            	indent_list[index] = 0;
            else
	            indent_list[index] = this._language.QueryFormateIndent(index, delete_count);
        }

        var changed = false;
        for (var index = line_start; index <= line_end; 1)
        {
            var line = this._line_list[index];
            var old_indent = old_indent_list[index];
            var delete_count = delete_list[index];
            var indent = indent_list[index];

            // 检查是否需要格式化
            if (old_indent != indent)
            {
                // 先删除
                this._select_cursor.StartLineChar(index, 0);
                this._select_cursor.UpdateLineChar(index, delete_count);
                this._cursor.SetLineChar(index, 0);
                
                // 再插入
                var new_indent = "";
                for (var i = 1; i <= indent; 1)
                	new_indent = new_indent.." ";
                this.InsertText(new_indent, true, revoke_bind);

                changed = true;
                if (old_line == index) old_char += indent - delete_count;
            }
        }

        if (changed)
        {
            revoke_bind.complete = bind(this.DispatchChangedEvent, this);
            this._revoke_list.PushRevoke(revoke_bind);
            this._cursor.SetLineChar(old_line, old_char);
        }
    }

    // 删除多行tab键
    public fun MultiTabDelete(bool need_revoke, [Nullable]ALittle.RevokeBind revoke_bind) : bool
    {
		var insert_revoke:ALittle.RevokeBind;
        if (need_revoke) insert_revoke = new ALittle.RevokeBind();

        if (this._select_cursor.line_start == null || this._select_cursor.line_end == null) return false;

        var old_line_start = this._select_cursor.line_start;
        var old_char_start = this._select_cursor.char_start;
        var old_line_end = this._select_cursor.line_end;
        var old_char_end = this._select_cursor.char_end;

        var old_line = this._cursor.line;
        var old_char = this._cursor.char;

        var line_min = this._select_cursor.line_start;
        var line_max = this._select_cursor.line_end;
        if (line_min > line_max)
        {
            var temp = line_min;
            line_min = line_max;
            line_max = temp;
        }

        var changed = false;
        for (var index = line_min; index <= line_max; 1) 
        {
            var line = this._line_list[index];
            // 计算空格数
            var delete_count = 0;
            for (var i = 1; i <= 4; 1)
            {
                if (line.char_list[i].char == "\t")
                {
                    if (i == 1)
                    {
                        delete_count = 1;
                        break;
                    }
                    else
                        break;
                }
                elseif (line.char_list[i].char == " ")
					delete_count += 1;
                else
					break;
            }

            if (delete_count > 0)
            {
                changed = true;
        		if (this._language != null) this._language.DeleteText(index, 1, index, delete_count);
    			for (var char_index, char in line.char_list)
            	{
             	   char.pre_width -= this._ascii_width * 4;
             	   if (char.text != null)
						char.text.x -= this._ascii_width * 4;
            	}
            	line.container.width -= this._ascii_width * 4;
            	List_Splice(line.char_list, 1, delete_count);
            	line.char_count -= delete_count;
				if (index == old_line_start) old_char_start -= delete_count;
            	elseif (index == old_line_end) old_char_end -= delete_count;

                if (index == old_line) old_char -= delete_count;
            }
        }

        if (changed)
        {
            this._cursor.SetLineChar(old_line, old_char);
        	this._select_cursor.StartLineChar(old_line_start, old_char_start);
        	this._select_cursor.UpdateLineChar(old_line_end, old_char_end);

       	 var max_width = 0.0;
	        for (var index, line in this._line_list)
 	           if (line.container.width > max_width) max_width = line.container.width;
        	this._code_screen.container.width = max_width + CODE_LINE_NUMBER_WIDTH;
        	this._code_screen.AdjustScrollBar();

            if (this._find_map != null)
            {
                for (var index = line_min; index <= line_max; 1) 
                    this.UpdateLineFind(index);
            }

        	if (need_revoke)
        	{
            	var revoke = new AUICodeMultiTabDeleteRevoke(this, this._cursor, this._select_cursor
            		, old_line_start, old_char_start, old_line_end, old_char_end
            		, this._select_cursor.line_start, this._select_cursor.char_start, this._select_cursor.line_end, this._select_cursor.char_end
            		, revoke_bind == null);
            	insert_revoke.PushRevoke(revoke);
            	if (revoke_bind == null)
             	   this._revoke_list.PushRevoke(insert_revoke);
        	}
        }

        return true;
    }

    // 插入文本
    public fun InsertText(string content, bool need_revoke, [Nullable]ALittle.RevokeBind revoke_bind) : bool
    {
        var insert_revoke:ALittle.RevokeBind;
        if (need_revoke)
        {
            if (revoke_bind != null) insert_revoke = revoke_bind;
            else insert_revoke = new ALittle.RevokeBind();
        }

        var is_changed, delete_it_line, delete_it_char = this._select_cursor.DeleteSelect(need_revoke, insert_revoke);
        if (is_changed) this._cursor.SetLineChar(delete_it_line, delete_it_char);
        
        var line_list, line_count, max_width = this.CreateLines(content);
        if (line_count == 0) return is_changed;
        is_changed = true;

        if (this._language != null) this._language.InsertText(content, this._cursor.line, this._cursor.char);

        var old_it_line = this._cursor.line;
        var old_it_char = this._cursor.char;

        var split_pre_line:AUICodeLineInfo = this._line_list[this._cursor.line];
        var split_it_char = this._cursor.char;

        // 记录行编号
        var line_map = new Map<int, bool>();

        // 如果当前没有数据，那么就构建一个
        if (split_pre_line == null)
        {
            split_pre_line = new AUICodeLineInfo();
            split_pre_line.edit = this;
            split_pre_line.char_count = 0;
            split_pre_line.char_list = new List<AUICodeCharInfo>();
            split_pre_line.container = new AUICodeLineContainer(g_Control);
            split_pre_line.container._user_data = split_pre_line;
            split_pre_line.container.height = CODE_LINE_HEIGHT;
            this._code_linear.AddChild(split_pre_line.container);
            this._line_count += 1;
            this._line_list[this._line_count] = split_pre_line;

            line_map[this._line_count] = true;
        }

        // 把当前行拆成两行
        var split_next_line:AUICodeLineInfo = split_pre_line;
        var it_cursor_line = this._cursor.line;
        var it_cursor_char = this._cursor.char;

        line_map[this._cursor.line] = true;

        // 将插入的行位置空出来
        if (line_count > 1)
        {
            if (line_count <= 20)
            {
                // 先保存为局部变量，目的是为了提高执行效率
                var this_line_list = this._line_list;
                var this_line_count = this._line_count;
            
                // 保存当前行的位置
                var new_line_index = this._cursor.line;

                // 把当前行拆成两行
                {
                    split_next_line = new AUICodeLineInfo();
                    split_next_line.edit = this;
                    split_next_line.char_count = 0;
                    split_next_line.char_list = new List<AUICodeCharInfo>();
                    split_next_line.container = new AUICodeLineContainer(g_Control);
                    split_next_line.container._user_data = split_next_line;
                    split_next_line.container.height = CODE_LINE_HEIGHT;
                    // 把split_pre_line的后半段添加到split_next_line
                    for (var i = this._cursor.char + 1; i <= split_pre_line.char_count; 1)
                    {
                        split_next_line.char_count += 1;
                        split_next_line.char_list[split_next_line.char_count] = split_pre_line.char_list[i];
                        if (split_pre_line.char_list[i].text != null)
                            split_next_line.container.AddChild(split_pre_line.char_list[i].text);
                    }

                    // split_pre_line的后半段删除
                    var split_count = split_pre_line.char_count - this._cursor.char;
                    List_Splice(split_pre_line.char_list, this._cursor.char + 1, split_count);
                    split_pre_line.char_count -= split_count;
                }
                // 插入新的行
                var code_linear = this._code_linear;
                for (var i = 2; i < line_count; 1)
                {
                    var line = line_list[i];
                    new_line_index += 1;
                    code_linear.AddChild(line.container, new_line_index);
                    this_line_count += 1;
                    List_Insert(this_line_list, new_line_index, line);
                    line_map[new_line_index] = true;
                }
                // 插入拆分行（后半段）
                {
                    new_line_index += 1;
                    code_linear.AddChild(split_next_line.container, new_line_index);
                    List_Insert(this_line_list, new_line_index, split_next_line);
                    this_line_count += 1;
                    it_cursor_line = new_line_index;
                    it_cursor_char = 0;
                    line_map[new_line_index] = true;
                }

                // 把数量保存回去
                this._line_count = this_line_count;
            }
            else
            {
                // 先保存为局部变量，目的是为了提高执行效率
                var this_line_list = this._line_list;
                var this_line_count = this._line_count;
            
                var new_line_list = new List<AUICodeLineInfo>();
                var new_line_count = 0;

                // 处理开始那些行
                var cursor_line = this._cursor.line;
                this._code_linear.SpliceChild(cursor_line);
                for (var i = 1; i < cursor_line; 1)
                {
                    new_line_count += 1;
                    new_line_list[new_line_count] = this_line_list[i];
                }
                // 把当前行拆成两行
                {
                    split_next_line = new AUICodeLineInfo();
                    split_next_line.edit = this;
                    split_next_line.char_count = 0;
                    split_next_line.char_list = new List<AUICodeCharInfo>();
                    split_next_line.container = new AUICodeLineContainer(g_Control);
                    split_next_line.container._user_data = split_next_line;
                    split_next_line.container.height = CODE_LINE_HEIGHT;
                    // 把split_pre_line的后半段添加到split_next_line
                    for (var i = this._cursor.char + 1; i <= split_pre_line.char_count; 1)
                    {
                        split_next_line.char_count += 1;
                        split_next_line.char_list[split_next_line.char_count] = split_pre_line.char_list[i];
                        if (split_pre_line.char_list[i].text != null)
                            split_next_line.container.AddChild(split_pre_line.char_list[i].text);
                    }

                    // split_pre_line的后半段删除
                    var split_count = split_pre_line.char_count - this._cursor.char;
                    List_Splice(split_pre_line.char_list, this._cursor.char + 1, split_count);
                    split_pre_line.char_count -= split_count;

                    // 插入旧行（前半段）
                    var result = this._code_linear.AddChild(split_pre_line.container);
                    new_line_count += 1;
                    new_line_list[new_line_count] = split_pre_line;
                }
                // 插入新的行
                var code_linear = this._code_linear;
                for (var i = 2; i < line_count; 1)
                {
                    var line = line_list[i];
                    var result = code_linear.AddChild(line.container);
                    new_line_count += 1;
                    new_line_list[new_line_count] = line;

                    line_map[new_line_count] = true;
                }
                // 插入拆分行（后半段）
                {
                    var result = code_linear.AddChild(split_next_line.container);
                    new_line_count += 1;
                    new_line_list[new_line_count] = split_next_line;
                    it_cursor_line = new_line_count;
                    it_cursor_char = 0;

                    line_map[new_line_count] = true;
                }
                // 插入剩余行
                for (var i = this._cursor.line + 1; i <= this_line_count; 1)
                {
                    var line = this_line_list[i];
                    code_linear.AddChild(line.container);
                    new_line_count += 1;
                    new_line_list[new_line_count] = line;
                }

                // 使用新的列表和数量
                this._line_list = new_line_list;
                this._line_count = new_line_count;
            }
        }

        // 开始衔接起始行
        if (line_count > 0)
        {
            var line = line_list[1];
            var char_list = new List<AUICodeCharInfo>();
            var char_count = 0;
            split_pre_line.container._text.RemoveAllChild();
            // 插入旧的数据
            var pre_width = 0.0;
            for (var i = 1; i <= split_it_char; 1)
            {
                var char = split_pre_line.char_list[i];
                char.pre_width = pre_width;
                if (char.text != null) char.text.x = pre_width;
                split_pre_line.container.AddChar(char);
                char_count += 1;
                char_list[char_count] = char;
                pre_width += char.width;
            }
            // 插入新的数据
            for (var i = 1; i <= line.char_count; 1)
            {
                var char = line.char_list[i];
                char.pre_width = pre_width;
                if (char.text != null) char.text.x = pre_width;
                split_pre_line.container.AddChar(char);   
                char_count += 1;
                char_list[char_count] = char;
                pre_width += char.width;
            }
            // 如果只在起始行插入，那么光标移动到插入最后字符的位置
            if (line_count <= 1) it_cursor_char = char_count;
            // 插入后缀数据
            for (var i = split_it_char + 1; i <= split_pre_line.char_count; 1)
            {
                var char = split_pre_line.char_list[i];
                char.pre_width = pre_width;
                if (char.text != null) char.text.x = pre_width;
                split_pre_line.container.AddChar(char);   
                char_count += 1;
                char_list[char_count] = char;
                pre_width += char.width;
            }
            split_pre_line.char_count = char_count;
            split_pre_line.char_list = char_list;
            split_pre_line.container.width = pre_width;
        }

        // 开始衔接结束行
        if (line_count > 1)
        {
            var line = line_list[line_count];
            var char_list = new List<AUICodeCharInfo>();
            var char_count = 0;
            split_next_line.container._text.RemoveAllChild();
            // 插入新的数据
            var pre_width = 0.0;
            for (var i = 1; i <= line.char_count; 1)
            {
                var char = line.char_list[i];
                char.pre_width = pre_width;
                if (char.text != null) char.text.x = pre_width;
                split_next_line.container.AddChar(char);   
                char_count += 1;
                char_list[char_count] = char;
                pre_width += char.width;
            }
        	// 那么光标移动到插入最后字符的位置
            it_cursor_char = char_count;
            // 插入后缀数据
            for (var i = 1; i <= split_next_line.char_count; 1)
            {
                var char = split_next_line.char_list[i];
                char.pre_width = pre_width;
                if (char.text != null) char.text.x = pre_width;
                split_next_line.container.AddChar(char);   
                char_count += 1;
                char_list[char_count] = char;
                pre_width += char.width;
            }
            split_next_line.char_count = char_count;
            split_next_line.char_list = char_list;
            split_next_line.container.width = pre_width;
        }

        max_width = 0.0;
        var this_line_list = this._line_list;
        for (var index, line in this_line_list)
            if (line.container.width > max_width) max_width = line.container.width;
        this._code_screen.container.width = max_width + CODE_LINE_NUMBER_WIDTH;
        this._code_screen.container.height = this._line_count * CODE_LINE_HEIGHT + CODE_PAD_LINES * CODE_LINE_HEIGHT;
        this._code_screen.AdjustScrollBar();

        this._cursor.SetLineChar(it_cursor_line, it_cursor_char);

        if (need_revoke)
        {
            var revoke = new AUICodeInsertTextRevoke(this, this._cursor, this._select_cursor, old_it_line, old_it_char, it_cursor_line, it_cursor_char, content, revoke_bind == null);
            insert_revoke.PushRevoke(revoke);
            if (revoke_bind == null)
                this._revoke_list.PushRevoke(insert_revoke);
        }

        if (this._find_map != null)
        {
            for (var line_index, _ in line_map)
                this.UpdateLineFind(line_index);
        }
        this.UpdateLineNumber();
        return is_changed;
    }

    public fun GetText() : string
    {
        if (this._file_path == null) return "";

        var text_list = new List<string>();
        var text_count = 0;
        for (var i, line in this._line_list)
        {
            for (var j, char in line.char_list)
            {
                text_count += 1;
                text_list[text_count] = char.char;
            }
        }
        return ALittle.String_Join(text_list, "");
    }

    public fun GetSelectText() : string
    {
        return this._select_cursor.GetSelectText();
    }

    public fun GetTargetText(int line_start, int char_start, int line_end, int char_end) : string
    {
        return this._select_cursor.GetTargetText(line_start, char_start, line_end, char_end);
    }

    public fun Save() : bool
    {
        if (this._file_path == null) return false;

        var text_list = new List<string>();
        var text_count = 0;
        for (var i, line in this._line_list)
        {
            for (var j, char in line.char_list)
            {
                text_count += 1;
                text_list[text_count] = char.char;
            }
        }
        ALittle.File_WriteTextToFile(ALittle.String_Join(text_list, ""), this._file_path);

        this.OnSave();
        return true;
	}

    public fun EditFocus(int line_start, int char_start, int line_end, int char_end, bool edit_focus)
    {
        if (edit_focus) this._edit_quad.DelayFocus();

        // 如果行数为0，那么直接返回
        if (this._line_count <= 0)
        {
            this._select_cursor.Hide();
            this._cursor.SetLineChar(1, 0);
            this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
            return;
        }

        if (line_start == null || char_start == null) return;

        if (char_start > 0) char_start -= 1;
        if (line_end == null || char_end == null)
        {
            this._select_cursor.Hide();

            if (line_start > this._line_count)
            {
                this._cursor.SetLineChar(1, 0);
                this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
                return;
            }
            var line = this._line_list[line_start];
            var count = line.char_count;
            while (count > 0 && line.char_list[count].width <= 0)
                -- count;
            if (char_start > count) char_start = count;
            this._cursor.SetLineChar(line_start, char_start);
            this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
            return;
        }

        if (line_start > this._line_count || line_end > this._line_count)
        {
            this._select_cursor.Hide();
            this._cursor.SetLineChar(1, 0);
            this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
            return;
        }

        {
            var line = this._line_list[line_start];
            var count = line.char_count;
            while (count > 0 && line.char_list[count].width <= 0)
                -- count;
            if (char_start > count) char_start = count;
        }

        {
            var line = this._line_list[line_end];
            var count = line.char_count;
            while (count > 0 && line.char_list[count].width <= 0)
                -- count;
            if (char_end > count) char_end = count;
        }

        if (line_start == line_end && char_start == char_end)
        {
            this._select_cursor.Hide();
            this._cursor.SetLineChar(line_start, char_start);
            this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
            return;
        }

        this._cursor.SetLineChar(line_start, char_start);
        this._select_cursor.StartLineChar(line_start, char_start);
        this._select_cursor.UpdateLineChar(line_end, char_end);
        this.FocusLineCharToCenter(this._cursor.line, this._cursor.char);
    }
}
