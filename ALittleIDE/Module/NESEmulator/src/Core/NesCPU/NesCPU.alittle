
namespace NESEmulator;

// CPU内存寻址长度
protected var CPU_MEM_LEN = 0x10000;

protected enum NesCPUIRQ
{
    IRQ_NORMAL = 0;
    IRQ_NMI = 1;
    IRQ_RESET = 2;
}

protected class NesCPU
{
    private NesCore _nes;

    // 总内存，长度为CPU_MEM_LEN
    public Map<int, int> _mem;

    // 寄存器
    private int _reg_acc;	// 累加器
    private int _reg_x;	// 循环计数器
    private int _reg_y;	// 循环计数器
    private int _reg_sp;	// 堆栈寄存器，其值为 0x00 ~ 0xFF，对应着 CPU 总线上的 0x100 ~ 0x1FF
    private int _reg_pc;	// 程序计数器，记录下一条指令地址
    private int _reg_pc_new;

    // 标志寄存器，它实际上只有 6bit，但是我们可以看成 8bit
    // BIT	名称	含义
    // 0	C	进位标志，如果计算结果产生进位，则置 1
    // 1	Z	零标志，如果结算结果为 0，则置 1
    // 2	I	中断去使能标志，置 1 则可屏蔽掉 IRQ 中断
    // 3	D	十进制模式，未使用
    // 4	B	BRK，后面解释
    // 5	U	未使用，后面解释
    // 6	V	溢出标志，如果结算结果产生了溢出，则置 1
    // 7	N	负标志，如果计算结果为负，则置 1
    private int _reg_status;	

    private int _f_carry;
    private int _f_zero;
    private int _f_interrupt;
    private int _f_interrupt_new;
    private int _f_decimal;
    private int _f_brk;
    private int _f_brk_new;
    private int _f_notused;
    private int _f_notused_new;
    private int _f_overflow;
    private int _f_sign;

    // 指令集
    private NesCPUOpData _op_data;

    // 指令周期数
    public int _cycles_to_halt = 0;

    // 崩溃标记
    private bool _crash = false;

    // 请求中断
    private bool _irq_requested = false;
    // 中断类型
    private int _irq_type;

    public ctor(NesCore nes)
    {
        this._nes = nes;

        this.Reset();
    }

    public fun Reset()
    {
        // 初始化总内存
        this._mem = new Map<int, int>();
        for (var i = 0; i < CPU_MEM_LEN; 1)
            this._mem[i] = 0;

        // 主机内存，[0x0000, 0x2000)
        // 实际可用只有最低的0x800，剩下部分都是这块的镜像
        for (var i = 0; i < 0x2000; 1)
            this._mem[i] = 0xff;

        for (var p = 0; p < 4; 1)
        {
            var j = p * 0x800;
            this._mem[j + 0x008] = 0xf7;
            this._mem[j + 0x009] = 0xef;
            this._mem[j + 0x00a] = 0xdf;
            this._mem[j + 0x00f] = 0xbf;
        }
        // 初始化剩余内存
        for (var k = 0x2001; k < CPU_MEM_LEN; 1)
            this._mem[k] = 0;

        // 寄存器
        this._reg_acc = 0;
        this._reg_x = 0;
        this._reg_y = 0;
        // 栈寄存器
        this._reg_sp = 0x01ff;
        // 指令寄存器
        this._reg_pc = 0x8000 - 1;
        this._reg_pc_new = this._reg_pc;
        // 状态寄存器
        this._reg_status = 0x28;

        this.SetStatus(this._reg_status);

        // 设置标记
        this._f_carry = 0;
        this._f_decimal = 0;
        this._f_interrupt = 1;
        this._f_interrupt_new = 1;
        this._f_overflow = 0;
        this._f_sign = 0;
        this._f_zero = 1;

        this._f_notused = 1;
        this._f_notused_new = 1;
        this._f_brk = 1;
        this._f_brk_new = 1;

        // 创建指令集
        this._op_data = new NesCPUOpData();
        // 指令周期数
        this._cycles_to_halt = 0;
        // 重置崩溃标记
        this._crash = false;

        // 重置中断
        this._irq_requested = false;
        this._irq_type = null;
    }

    // 模拟单核CPU指令，返回周期数
    public fun Emulate() : int
    {
        var temp:int = null;
        var add:int = null;

        // 检查中断
        if (this._irq_requested)
        {
            temp = this._f_carry |
            		(ConditionExpr(this._f_zero == 0, 1, 0) <<- 1) |
                    (this._f_interrupt <<- 2) |
                    (this._f_decimal <<- 3) |
                    (this._f_brk <<- 4) |
                    (this._f_notused <<- 5) |
                    (this._f_overflow <<- 6) |
                    (this._f_sign <<- 7);

            // 保存pc和中断地址
            this._reg_pc_new = this._reg_pc;
            this._f_interrupt_new = this._f_interrupt;

            // 处理中断
            if (this._irq_type == NesCPUIRQ.IRQ_NORMAL)
            {
                if (this._f_interrupt == 0)
                    this.DoIrq(temp);
            }
            elseif (this._irq_type == NesCPUIRQ.IRQ_NMI)
            {
                this.DoNonMaskableInterrupt(temp);
            }
            elseif (this._irq_type == NesCPUIRQ.IRQ_RESET)
            {
                this.DoResetInterrupt();
            }

            // 恢复中断前的地址
            this._reg_pc = this._reg_pc_new;
            this._f_interrupt = this._f_interrupt_new;
            this._f_brk = this._f_brk_new;
            this._irq_requested = false;
        }

        // 获取下一条指令
        var op = this._nes._mmap.Load(this._reg_pc + 1);
        // 指令信息
        var op_info = this._op_data._op_data[op];
        // 指令的周期数
        var cycle_count = op_info ->> 24;
        // 指令而外的周期数
        var cycle_add = 0;
        // 指令地址模式
        var addr_mode = (op_info ->> 8) & 0xff;

        // 保存当前指令地址
        var op_addr = this._reg_pc;
        // 设置下一条指令地址
        this._reg_pc += (op_info ->> 16) & 0xff;

        var addr = 0;

        // Zero Page mode. Use the address given after the opcode,
        // but without high byte.
        if (addr_mode == 0)
        {
            addr = this.Load(op_addr + 2);
        }
        // Relative mode
        elseif (addr_mode == 1)
        {
            addr = this.Load(op_addr + 2);
            if (addr < 0x80)
                addr += this._reg_pc;
            else
                addr += this._reg_pc - 256;
        }
        // Ignore. Address is implied in instruction.
        elseif (addr_mode == 2)
        {

        }
        // Absolute mode. Use the two bytes following the opcode as
        // an address.
        elseif (addr_mode == 3)
        {
            addr = this.Load16bit(op_addr + 2);
        }
        // Accumulator mode. The address is in the accumulator
        // register.
        elseif (addr_mode == 4)
        {
            addr = this._reg_acc;
        }
        // Immediate mode. The value is given after the opcode.
        elseif (addr_mode == 5)
        {
            addr = this._reg_pc;
        }
        // Zero Page Indexed mode, X as index. Use the address given
        // after the opcode, then add the
        // X register to it to get the final address.
        elseif (addr_mode == 6)
        {
            addr = (this.Load(op_addr + 2) + this._reg_x) & 0xff;
        }
        // Zero Page Indexed mode, Y as index. Use the address given
        // after the opcode, then add the
        // Y register to it to get the final address.
        elseif (addr_mode == 7)
        {
            addr = (this.Load(op_addr + 2) + this._reg_y) & 0xff;
        }
        // Absolute Indexed Mode, X as index. Same as zero page
        // indexed, but with the high byte.
        elseif (addr_mode == 8)
        {
            addr = this.Load16bit(op_addr + 2);
            if ((addr & 0xff00) != ((addr + this._reg_x) & 0xff00))
        		cycle_add = 1;
        	addr += this._reg_x;
        }
        // Absolute Indexed Mode, Y as index. Same as zero page
        // indexed, but with the high byte.
        elseif (addr_mode == 9)
        {
            addr = this.Load16bit(op_addr + 2);
            if ((addr & 0xff00) != ((addr + this._reg_y) & 0xff00))
        		cycle_add = 1;
        	addr += this._reg_y;
        }
        // Pre-indexed Indirect mode. Find the 16-bit address
        // starting at the given location plus
        // the current X register. The value is the contents of that
        // address.
        elseif (addr_mode == 10)
        {
            addr = this.Load(op_addr + 2);
            if ((addr & 0xff00) != ((addr + this._reg_x) & 0xff00))
        		cycle_add = 1;
	        addr += this._reg_x;
            addr = addr & 0xff;
        	addr = this.Load16bit(addr);
        }
        // Post-indexed Indirect mode. Find the 16-bit address
        // contained in the given location
        // (and the one following). Add to that address the contents
        // of the Y register. Fetch the value
        // stored at that adress.
        elseif (addr_mode == 11)
        {
            addr = this.Load16bit(this.Load(op_addr + 2));
            if ((addr & 0xff00) != ((addr + this._reg_y) & 0xff00))
        		cycle_add = 1;
        	addr += this._reg_y;
        }
        // Indirect Absolute mode. Find the 16-bit address contained
        // at the given location.
        elseif (addr_mode == 12)
        {
            addr = this.Load16bit(op_addr + 2); // Find op
            if (addr < 0x1fff)
                addr = this._mem[addr] + (this._mem[(addr & 0xff00) | (((addr & 0xff) + 1) & 0xff)] <<- 8); // Read from address given in op
            else
                addr = this._nes._mmap.Load(addr) + (this._nes._mmap.Load((addr & 0xff00) | (((addr & 0xff) + 1) & 0xff)) <<- 8);
        }

        // 让地址的值不要超过0xFFFF
        addr = addr & 0xFFFF;

        // 解析并执行指令
        var op_type = op_info & 0xFF;
        if (op_type == 0) {
            // *******
            // * ADC *
            // *******

            // Add with carry.
            temp = this._reg_acc + this.Load(addr) + this._f_carry;

            if (((this._reg_acc ^ this.Load(addr)) & 0x80) == 0 && ((this._reg_acc ^ temp) & 0x80) != 0)
                this._f_overflow = 1;
            else
                this._f_overflow = 0;

            this._f_carry = ConditionExpr(temp > 255, 1, 0);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            this._reg_acc = temp & 255;
            cycle_count += cycle_add;
        }
        elseif (op_type == 1) {
            // *******
            // * AND *
            // *******

            // AND memory with accumulator.
            this._reg_acc = this._reg_acc & this.Load(addr);
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 2) {
            // *******
            // * ASL *
            // *******

            // Shift left one bit
            if (addr_mode == 4) {
                // ADDR_ACC = 4

                this._f_carry = (this._reg_acc ->> 7) & 1;
                this._reg_acc = (this._reg_acc <<- 1) & 255;
                this._f_sign = (this._reg_acc ->> 7) & 1;
                this._f_zero = this._reg_acc;
            } else {
                temp = this.Load(addr);
                this._f_carry = (temp ->> 7) & 1;
                temp = (temp <<- 1) & 255;
                this._f_sign = (temp ->> 7) & 1;
                this._f_zero = temp;
                this.Write(addr, temp);
            }
        }
        elseif (op_type == 3) {
            // *******
            // * BCC *
            // *******

            // Branch on carry clear
            if (this._f_carry == 0) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
            	this._reg_pc = addr;
            }
        }
        elseif (op_type == 4) {
            // *******
            // * BCS *
            // *******

            // Branch on carry set
            if (this._f_carry == 1) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 5) {
            // *******
            // * BEQ *
            // *******

            // Branch on zero
            if (this._f_zero == 0) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 6) {
            // *******
            // * BIT *
            // *******

            temp = this.Load(addr);
            this._f_sign = (temp ->> 7) & 1;
            this._f_overflow = (temp ->> 6) & 1;
            temp = temp & this._reg_acc;
            this._f_zero = temp;
        }
        elseif (op_type == 7) {
            // *******
            // * BMI *
            // *******

            // Branch on negative result
            if (this._f_sign == 1) {
                ++cycle_count;
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 8) {
            // *******
            // * BNE *
            // *******

            // Branch on not zero
            if (this._f_zero != 0) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 9) {
            // *******
            // * BPL *
            // *******

            // Branch on positive result
            if (this._f_sign == 0) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 10) {
            // *******
            // * BRK *
            // *******

            this._reg_pc += 2;
            this.Push((this._reg_pc ->> 8) & 255);
            this.Push(this._reg_pc & 255);
            this._f_brk = 1;

            this.Push(
                 this._f_carry |
                 (ConditionExpr(this._f_zero == 0, 1, 0) <<- 1) |
                 (this._f_interrupt <<- 2) |
                 (this._f_decimal <<- 3) |
                 (this._f_brk <<- 4) |
                 (this._f_notused <<- 5) |
                 (this._f_overflow <<- 6) |
                 (this._f_sign <<- 7)
                 );

            this._f_interrupt = 1;
            //this._reg_pc = load(0xFFFE) | (load(0xFFFF) <<- 8);
            this._reg_pc = this.Load16bit(0xfffe);
            --this._reg_pc;
        }
        elseif (op_type == 11) {
            // *******
            // * BVC *
            // *******

            // Branch on overflow clear
            if (this._f_overflow == 0) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 12) {
            // *******
            // * BVS *
            // *******

            // Branch on overflow set
            if (this._f_overflow == 1) {
                cycle_count += ConditionExpr((op_addr & 0xff00) != (addr & 0xff00), 2, 1);
                this._reg_pc = addr;
            }
        }
        elseif (op_type == 13) {
            // *******
            // * CLC *
            // *******

            // Clear carry flag
            this._f_carry = 0;
        }
        elseif (op_type == 14) {
            // *******
            // * CLD *
            // *******

            // Clear decimal flag
            this._f_decimal = 0;
        }
        elseif (op_type == 15) {
            // *******
            // * CLI *
            // *******

            // Clear interrupt flag
            this._f_interrupt = 0;
        }
        elseif (op_type == 16) {
            // *******
            // * CLV *
            // *******

            // Clear overflow flag
            this._f_overflow = 0;
        }
        elseif (op_type == 17) {
            // *******
            // * CMP *
            // *******

            // Compare memory and accumulator:
            temp = this._reg_acc - this.Load(addr);
            this._f_carry = ConditionExpr(temp >= 0, 1, 0);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            cycle_count += cycle_add;
        }
        elseif (op_type == 18) {
            // *******
            // * CPX *
            // *******

            // Compare memory and index X:
            temp = this._reg_x - this.Load(addr);
            this._f_carry = ConditionExpr(temp >= 0, 1, 0);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
        }
        elseif (op_type == 19) {
            // *******
            // * CPY *
            // *******

            // Compare memory and index Y:
            temp = this._reg_y - this.Load(addr);
            this._f_carry = ConditionExpr(temp >= 0, 1, 0);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
        }
        elseif (op_type == 20) {
            // *******
            // * DEC *
            // *******

            // Decrement memory by one:
            temp = (this.Load(addr) - 1) & 0xff;
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp;
            this.Write(addr, temp);
        }
        elseif (op_type == 21) {
            // *******
            // * DEX *
            // *******

            // Decrement index X by one:
            this._reg_x = (this._reg_x - 1) & 0xff;
            this._f_sign = (this._reg_x ->> 7) & 1;
            this._f_zero = this._reg_x;
        }
        elseif (op_type == 22) {
            // *******
            // * DEY *
            // *******

            // Decrement index Y by one:
            this._reg_y = (this._reg_y - 1) & 0xff;
            this._f_sign = (this._reg_y ->> 7) & 1;
            this._f_zero = this._reg_y;
        }
        elseif (op_type == 23) {
            // *******
            // * EOR *
            // *******

            // XOR Memory with accumulator, store in accumulator:
            this._reg_acc = (this.Load(addr) ^ this._reg_acc) & 0xff;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
            cycle_count += cycle_add;
        }
        elseif (op_type == 24) {
            // *******
            // * INC *
            // *******

            // Increment memory by one:
            temp = (this.Load(addr) + 1) & 0xff;
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp;
            this.Write(addr, temp & 0xff);
        }
        elseif (op_type == 25) {
            // *******
            // * INX *
            // *******

            // Increment index X by one:
            this._reg_x = (this._reg_x + 1) & 0xff;
            this._f_sign = (this._reg_x ->> 7) & 1;
            this._f_zero = this._reg_x;
        }
        elseif (op_type == 26) {
            // *******
            // * INY *
            // *******

            // Increment index Y by one:
            ++this._reg_y;
            this._reg_y = this._reg_y & 0xff;
            this._f_sign = (this._reg_y ->> 7) & 1;
            this._f_zero = this._reg_y;
        }
        elseif (op_type == 27) {
            // *******
            // * JMP *
            // *******

            // Jump to new location:
            this._reg_pc = addr - 1;
        }
        elseif (op_type == 28) {
            // *******
            // * JSR *
            // *******

            // Jump to new location, saving return address.
            // Push return address on stack:
            this.Push((this._reg_pc ->> 8) & 255);
            this.Push(this._reg_pc & 255);
            this._reg_pc = addr - 1;
        }
        elseif (op_type == 29) {
            // *******
            // * LDA *
            // *******

            // Load accumulator with memory:
            this._reg_acc = this.Load(addr);
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
            cycle_count += cycle_add;
        }
        elseif (op_type == 30) {
            // *******
            // * LDX *
            // *******

            // Load index X with memory:
            this._reg_x = this.Load(addr);
            this._f_sign = (this._reg_x ->> 7) & 1;
            this._f_zero = this._reg_x;
            cycle_count += cycle_add;
        }
        elseif (op_type == 31) {
            // *******
            // * LDY *
            // *******

            // Load index Y with memory:
            this._reg_y = this.Load(addr);
            this._f_sign = (this._reg_y ->> 7) & 1;
            this._f_zero = this._reg_y;
            cycle_count += cycle_add;
        }
        elseif (op_type == 32) {
            // *******
            // * LSR *
            // *******

            // Shift right one bit:
            if (addr_mode == 4) {
                // ADDR_ACC

                temp = this._reg_acc & 0xff;
                this._f_carry = temp & 1;
                temp = temp ->> 1;
                this._reg_acc = temp;
            } else {
                temp = this.Load(addr) & 0xff;
                this._f_carry = temp & 1;
                temp = temp ->> 1;
                this.Write(addr, temp);
            }
            this._f_sign = 0;
            this._f_zero = temp;
        }
        elseif (op_type == 33) {
            // *******
            // * NOP *
            // *******

            // No OPeration.
            // Ignore.
        }
        elseif (op_type == 34) {
            // *******
            // * ORA *
            // *******

            // OR memory with accumulator, store in accumulator.
            temp = (this.Load(addr) | this._reg_acc) & 255;
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp;
            this._reg_acc = temp;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 35) {
            // *******
            // * PHA *
            // *******

            // Push accumulator on stack
            this.Push(this._reg_acc);
        }
        elseif (op_type == 36) {
            // *******
            // * PHP *
            // *******

            // Push processor status on stack
            this._f_brk = 1;
            this.Push(
                 this._f_carry |
                 (ConditionExpr(this._f_zero == 0, 1, 0) <<- 1) |
                 (this._f_interrupt <<- 2) |
                 (this._f_decimal <<- 3) |
                 (this._f_brk <<- 4) |
                 (this._f_notused <<- 5) |
                 (this._f_overflow <<- 6) |
                 (this._f_sign <<- 7)
                 );
        }
        elseif (op_type == 37) {
            // *******
            // * PLA *
            // *******

            // Pull accumulator from stack
            this._reg_acc = this.Pull();
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
        }
        elseif (op_type == 38) {
            // *******
            // * PLP *
            // *******

            // Pull processor status from stack
            temp = this.Pull();
            this._f_carry = temp & 1;
            this._f_zero = ConditionExpr(((temp ->> 1) & 1) == 1, 0, 1);
            this._f_interrupt = (temp ->> 2) & 1;
            this._f_decimal = (temp ->> 3) & 1;
            this._f_brk = (temp ->> 4) & 1;
            this._f_notused = (temp ->> 5) & 1;
            this._f_overflow = (temp ->> 6) & 1;
            this._f_sign = (temp ->> 7) & 1;

            this._f_notused = 1;
        }
        elseif (op_type == 39) {
            // *******
            // * ROL *
            // *******

            // Rotate one bit left
            if (addr_mode == 4) {
                // ADDR_ACC = 4

                temp = this._reg_acc;
                add = this._f_carry;
                this._f_carry = (temp ->> 7) & 1;
                temp = ((temp <<- 1) & 0xff) + add;
                this._reg_acc = temp;
            } else {
                temp = this.Load(addr);
                add = this._f_carry;
                this._f_carry = (temp ->> 7) & 1;
                temp = ((temp <<- 1) & 0xff) + add;
                this.Write(addr, temp);
            }
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp;
        }
        elseif (op_type == 40) {
            // *******
            // * ROR *
            // *******

            // Rotate one bit right
            if (addr_mode == 4) {
                // ADDR_ACC = 4

                add = this._f_carry <<- 7;
                this._f_carry = this._reg_acc & 1;
                temp = (this._reg_acc ->> 1) + add;
                this._reg_acc = temp;
            } else {
                temp = this.Load(addr);
                add = this._f_carry <<- 7;
                this._f_carry = temp & 1;
                temp = (temp ->> 1) + add;
                this.Write(addr, temp);
            }
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp;
        }
        elseif (op_type == 41) {
            // *******
            // * RTI *
            // *******

            // Return from interrupt. Pull status and PC from stack.

            temp = this.Pull();
            this._f_carry = temp & 1;
            this._f_zero = ConditionExpr(((temp ->> 1) & 1) == 0, 1, 0);
            this._f_interrupt = (temp ->> 2) & 1;
            this._f_decimal = (temp ->> 3) & 1;
            this._f_brk = (temp ->> 4) & 1;
            this._f_notused = (temp ->> 5) & 1;
            this._f_overflow = (temp ->> 6) & 1;
            this._f_sign = (temp ->> 7) & 1;

            this._reg_pc = this.Pull();
            this._reg_pc += this.Pull() <<- 8;
            if (this._reg_pc == 0xffff) {
                return null;
            }
            --this._reg_pc;
            this._f_notused = 1;
        }
        elseif (op_type == 42) {
            // *******
            // * RTS *
            // *******

            // Return from subroutine. Pull PC from stack.

            this._reg_pc = this.Pull();
            this._reg_pc += this.Pull() <<- 8;

            if (this._reg_pc == 0xffff) {
                return null; // return from NSF play routine:
            }
        }
        elseif (op_type == 43) {
            // *******
            // * SBC *
            // *******

            temp = this._reg_acc - this.Load(addr) - (1 - this._f_carry);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            if (((this._reg_acc ^ temp) & 0x80) != 0 && ((this._reg_acc ^ this.Load(addr)) & 0x80) != 0) {
                this._f_overflow = 1;
            } else {
                this._f_overflow = 0;
            }
            if (temp < 0)
                this._f_carry = 0;
            else
                this._f_carry = 1;
            this._reg_acc = temp & 0xff;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 44) {
            // *******
            // * SEC *
            // *******

            // Set carry flag
            this._f_carry = 1;
        }
        elseif (op_type == 45) {
            // *******
            // * SED *
            // *******

            // Set decimal mode
            this._f_decimal = 1;
        }
        elseif (op_type == 46) {
            // *******
            // * SEI *
            // *******

            // Set interrupt disable status
            this._f_interrupt = 1;
        }
        elseif (op_type == 47) {
            // *******
            // * STA *
            // *******

            // Store accumulator in memory
            this.Write(addr, this._reg_acc);
        }
        elseif (op_type == 48) {
            // *******
            // * STX *
            // *******

            // Store index X in memory
            this.Write(addr, this._reg_x);
        }
        elseif (op_type == 49) {
            // *******
            // * STY *
            // *******

            // Store index Y in memory:
            this.Write(addr, this._reg_y);
        }
        elseif (op_type == 50) {
            // *******
            // * TAX *
            // *******

            // Transfer accumulator to index X:
            this._reg_x = this._reg_acc;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
        }
        elseif (op_type == 51) {
            // *******
            // * TAY *
            // *******

            // Transfer accumulator to index Y:
            this._reg_y = this._reg_acc;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
        }
        elseif (op_type == 52) {
            // *******
            // * TSX *
            // *******

            // Transfer stack pointer to index X:
            this._reg_x = this._reg_sp - 0x0100;
            this._f_sign = (this._reg_sp ->> 7) & 1;
            this._f_zero = this._reg_x;
        }
        elseif (op_type == 53) {
            // *******
            // * TXA *
            // *******

            // Transfer index X to accumulator:
            this._reg_acc = this._reg_x;
            this._f_sign = (this._reg_x ->> 7) & 1;
            this._f_zero = this._reg_x;
        }
        elseif (op_type == 54) {
            // *******
            // * TXS *
            // *******

            // Transfer index X to stack pointer:
            this._reg_sp = this._reg_x + 0x0100;
            this.StackWrap();
        }
        elseif (op_type == 55) {
            // *******
            // * TYA *
            // *******

            // Transfer index Y to accumulator:
            this._reg_acc = this._reg_y;
            this._f_sign = (this._reg_y ->> 7) & 1;
            this._f_zero = this._reg_y;
        }
        elseif (op_type == 56) {
            // *******
            // * ALR *
            // *******

            // Shift right one bit after ANDing:
            temp = this._reg_acc & this.Load(addr);
            this._f_carry = temp & 1;
            this._f_zero = temp ->> 1;
            this._reg_acc = this._f_zero;
            this._f_sign = 0;
        }
        elseif (op_type == 57) {
            // *******
            // * ANC *
            // *******

            // AND accumulator, setting carry to bit 7 result.
            this._f_zero = this._reg_acc & this.Load(addr);
            this._reg_acc = this._f_zero;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_carry = this._f_sign;
        }
        elseif (op_type == 58) {
            // *******
            // * ARR *
            // *******

            // Rotate right one bit after ANDing:
            temp = this._reg_acc & this.Load(addr);
            this._f_zero = (temp ->> 1) + (this._f_carry <<- 7);
            this._reg_acc = this._f_zero;
            this._f_sign = this._f_carry;
            this._f_carry = (temp ->> 7) & 1;
            this._f_overflow = ((temp ->> 7) ^ (temp ->> 6)) & 1;
        }
        elseif (op_type == 59) {
            // *******
            // * AXS *
            // *******

            // Set X to (X AND A) - value.
            temp = (this._reg_x & this._reg_acc) - this.Load(addr);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            if (
            ((this._reg_x ^ temp) & 0x80) != 0 &&
            ((this._reg_x ^ this.Load(addr)) & 0x80) != 0
            ) {
                this._f_overflow = 1;
            } else {
                this._f_overflow = 0;
            }
            if (temp < 0)
                this._f_carry = 0;
            else
                this._f_carry = 1;
            this._reg_x = temp & 0xff;
        }
        elseif (op_type == 60) {
            // *******
            // * LAX *
            // *******

            // Load A and X with memory:
            this._f_zero = this.Load(addr);
            this._reg_x = this._f_zero;
            this._reg_acc = this._reg_x;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            cycle_count += cycle_add;
        }
        elseif (op_type == 61) {
            // *******
            // * SAX *
            // *******

            // Store A AND X in memory:
            this.Write(addr, this._reg_acc & this._reg_x);
        }
        elseif (op_type == 62) {
            // *******
            // * DCP *
            // *******

            // Decrement memory by one:
            temp = (this.Load(addr) - 1) & 0xff;
            this.Write(addr, temp);

            // Then compare with the accumulator:
            temp = this._reg_acc - temp;
            this._f_carry = ConditionExpr(temp >= 0, 1, 0);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 63) {
            // *******
            // * ISC *
            // *******

            // Increment memory by one:
            temp = (this.Load(addr) + 1) & 0xff;
            this.Write(addr, temp);

            // Then subtract from the accumulator:
            temp = this._reg_acc - temp - (1 - this._f_carry);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            if (((this._reg_acc ^ temp) & 0x80) != 0 && ((this._reg_acc ^ this.Load(addr)) & 0x80) != 0) {
                this._f_overflow = 1;
            } else {
                this._f_overflow = 0;
            }
            this._f_carry = ConditionExpr(temp < 0, 0, 1);
            this._reg_acc = temp & 0xff;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 64) {
            // *******
            // * RLA *
            // *******

            // Rotate one bit left
            temp = this.Load(addr);
            add = this._f_carry;
            this._f_carry = (temp ->> 7) & 1;
            temp = ((temp <<- 1) & 0xff) + add;
            this.Write(addr, temp);

            // Then AND with the accumulator.
            this._reg_acc = this._reg_acc & temp;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 65) {
            // *******
            // * RRA *
            // *******

            // Rotate one bit right
            temp = this.Load(addr);
            add = this._f_carry <<- 7;
            this._f_carry = temp & 1;
            temp = (temp ->> 1) + add;
            this.Write(addr, temp);

            // Then add to the accumulator
            temp = this._reg_acc + this.Load(addr) + this._f_carry;

            if (
            ((this._reg_acc ^ this.Load(addr)) & 0x80) == 0 &&
            ((this._reg_acc ^ temp) & 0x80) != 0
            ) {
                this._f_overflow = 1;
            } else {
                this._f_overflow = 0;
            }
            this._f_carry = ConditionExpr(temp > 255, 1, 0);
            this._f_sign = (temp ->> 7) & 1;
            this._f_zero = temp & 0xff;
            this._reg_acc = temp & 255;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 66) {
            // *******
            // * SLO *
            // *******

            // Shift one bit left
            temp = this.Load(addr);
            this._f_carry = (temp ->> 7) & 1;
            temp = (temp <<- 1) & 255;
            this.Write(addr, temp);

            // Then OR with the accumulator.
            this._reg_acc = this._reg_acc | temp;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 67) {
            // *******
            // * SRE *
            // *******

            // Shift one bit right
            temp = this.Load(addr) & 0xff;
            this._f_carry = temp & 1;
            temp = temp ->> 1;
            this.Write(addr, temp);

            // Then XOR with the accumulator.
            this._reg_acc = this._reg_acc ^ temp;
            this._f_sign = (this._reg_acc ->> 7) & 1;
            this._f_zero = this._reg_acc;
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        elseif (op_type == 68) {
            // *******
            // * SKB *
            // *******

            // Do nothing
        }
        elseif (op_type == 69) {
            // *******
            // * IGN *
            // *******

            // Do nothing but load.
            // TODO: Properly implement the double-reads.
            this.Load(addr);
            if (addr_mode != 11) cycle_count += cycle_add; // PostIdxInd = 11
        }
        else {
            // *******
            // * ??? *
            // *******

            this._nes.Stop("Game crashed, invalid opcode at address $"..op_addr);
        }
        
        return cycle_count;
    }

    // 读取一个字节
    public fun Load(int addr) : int
    {
        if (addr < 0x2000)
        	return this._mem[addr & 0x7ff];
        else
        	return this._nes._mmap.Load(addr);
    }

    // 读取两个字节
    public fun Load16bit(int addr) : int
    {
        if (addr < 0x1fff)
            return this._mem[addr & 0x7ff] | (this._mem[(addr + 1) & 0x7ff] <<- 8);
        else
            return this._nes._mmap.Load(addr) | (this._nes._mmap.Load(addr + 1) <<- 8);
    }

    // 写入一个字节
    public fun Write(int addr, int value)
    {
        if (addr < 0x2000)
            this._mem[addr & 0x7ff] = value;
        else
            this._nes._mmap.Write(addr, value);
    }

    // 请求中断
    public fun RequestIrq(int type)
    {
        if (this._irq_requested)
        {
            if (type == NesCPUIRQ.IRQ_NORMAL)
                return;
        }
        this._irq_requested = true;
        this._irq_type = type;
    }

    // 清理中断
    public fun ClearIrq()
    {
        this._irq_requested = false;
        this._irq_type = null;
    }

    // 数据压栈
    public fun Push(int value)
    {
        this._nes._mmap.Write(this._reg_sp, value);
        --this._reg_sp;
        this._reg_sp = 0x0100 | (this._reg_sp & 0xff);
    }

    // 修正reg_sp数值范围
    public fun StackWrap()
    {
        this._reg_sp = 0x0100 | (this._reg_sp & 0xff);
    }

    // 数据出栈
    public fun Pull() : int
    {
        ++this._reg_sp;
        this._reg_sp = 0x0100 | (this._reg_sp & 0xff);
        return this._nes._mmap.Load(this._reg_sp);
    }

    // 内存地址是否跨页
    public fun PageCrossed(int addr1, int addr2) : bool
    {
        return (addr1 & 0xff00) != (addr2 & 0xff00);
    }

    // 累加指令周期
    public fun HaltCycles(int cycles)
    {
        this._cycles_to_halt += cycles;
    }

    // 执行NMI中断
    public fun DoNonMaskableInterrupt(int status)
    {
        // Check whether VBlank Interrupts are enabled
        if ((this._nes._mmap.Load(0x2000) & 128) != 0)
        {
            ++this._reg_pc_new;
            this.Push((this._reg_pc_new ->> 8) & 0xff);
            this.Push(this._reg_pc_new & 0xff);
            //this.F_INTERRUPT_NEW = 1;
            this.Push(status);

            this._reg_pc_new = this._nes._mmap.Load(0xfffa) | (this._nes._mmap.Load(0xfffb) <<- 8);
            --this._reg_pc_new;
        }
    }

    // 执行RESET中断
    public fun DoResetInterrupt()
    {
        this._reg_pc_new = this._nes._mmap.Load(0xfffc) | (this._nes._mmap.Load(0xfffd) <<- 8);
        --this._reg_pc_new;
    }

    // 执行普通中断
    public fun DoIrq(int status)
    {
        ++this._reg_pc_new;
        this.Push((this._reg_pc_new ->> 8) & 0xff);
        this.Push(this._reg_pc_new & 0xff);
        this.Push(status);
        this._f_interrupt_new = 1;
        this._f_brk_new = 0;

        this._reg_pc_new = this._nes._mmap.Load(0xfffe) | (this._nes._mmap.Load(0xffff) <<- 8);
        --this._reg_pc_new;
    }

    // 获取状态寄存器值
    public fun GetStatus() : int
    {
        return this._f_carry |
                (this._f_zero <<- 1) |
                (this._f_interrupt <<- 2) |
                (this._f_decimal <<- 3) |
                (this._f_brk <<- 4) |
                (this._f_notused <<- 5) |
                (this._f_overflow <<- 6) |
                (this._f_sign <<- 7);
    }

    // 设置状态寄存器的值
    public fun SetStatus(int st)
    {
        this._f_carry = st & 1;
        this._f_zero = (st ->> 1) & 1;
        this._f_interrupt = (st ->> 2) & 1;
        this._f_decimal = (st ->> 3) & 1;
        this._f_brk = (st ->> 4) & 1;
        this._f_notused = (st ->> 5) & 1;
        this._f_overflow = (st ->> 6) & 1;
        this._f_sign = (st ->> 7) & 1;
    }
}
