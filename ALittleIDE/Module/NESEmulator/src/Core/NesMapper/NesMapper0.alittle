
namespace NESEmulator;

protected class NesMapper0 : NesMapper
{
    private int _joy1_strobe_state;
    private int _joy2_strobe_state;
    private int _joypad_strobe_state;

    public fun Reset()
    {
        this._joy1_strobe_state = 0;
        this._joy2_strobe_state = 0;
        this._joypad_strobe_state = 0;

        NesMapper.Reset(this);
    }

    public fun Write(int address, int value)
    {
        // RAM
        if (address < 0x2000)
        {
            // Mirroring of RAM:
            this._nes._cpu._mem[address & 0x7ff] = value;
        }
        // Expansion ROM，SRAM，PRG-ROM
        else if (address > 0x4017)
        {
            this._nes._cpu._mem[address] = value;
            // Expansion ROM
            if (address >= 0x6000 && address < 0x8000)
            {
                // Write to persistent RAM
                this._nes.OnBatteryRamWrite(address, value);
            }
        }
        // I/O Registers中的Mirrors
        else if (address > 0x2007 && address < 0x4000)
        {
            this.RegWrite(0x2000 + (address & 0x7), value);
        }
        // I/O Registers除了Mirrors
        else
        {
            this.RegWrite(address, value);
        }
    }

    public fun Writelow(int address, int value)
    {
        // RAM
        if (address < 0x2000)
        {
            // Mirroring of RAM:
            this._nes._cpu._mem[address & 0x7ff] = value;
        }
        // Expansion ROM，SRAM，PRG-ROM
        else if (address > 0x4017)
        {
            this._nes._cpu._mem[address] = value;
        }
        // I/O Registers中的Mirrors
        else if (address > 0x2007 && address < 0x4000)
        {
            this.RegWrite(0x2000 + (address & 0x7), value);
        }
        // I/O Registers除了Mirrors
        else
        {
            this.RegWrite(address, value);
        }
    }

    public fun Load(int address) : int
    {
        // Wrap around:
        address = address & 0xffff;

        // Check address range:
        if (address > 0x4017) {
            // ROM:
            return this._nes._cpu._mem[address];
        } else if (address >= 0x2000) {
            // I/O Ports.
            return this.RegLoad(address);
        } else {
            // RAM (mirrored)
            return this._nes._cpu._mem[address & 0x7ff];
        }
    }

    public fun RegLoad(int address) : int
    {
        // use fourth nibble (0xF000)
        var type = address ->> 12;
        if (type == 0 || type == 1)
        {

        }
        // PPU Registers
        elseif (type == 2 || type == 3)
        {
            var reg = address & 0x7;
            if (reg == 0x0)
            {
                // 0x2000:
                // PPU Control Register 1.
                // (the value is stored both
                // in main memory and in the
                // PPU as flags):
                // (not in the real NES)
                return this._nes._cpu._mem[0x2000];
            }
            elseif (reg == 0x1)
            {
                // 0x2001:
                // PPU Control Register 2.
                // (the value is stored both
                // in main memory and in the
                // PPU as flags):
                // (not in the real NES)
                return this._nes._cpu._mem[0x2001];
            }
            elseif (reg == 0x2)
            {
                // 0x2002:
                // PPU Status Register.
                // The value is stored in
                // main memory in addition
                // to as flags in the PPU.
                // (not in the real NES)
                return this._nes._ppu.ReadStatusRegister();
            }
            elseif (reg == 0x3)
            {
                return 0;
            }
            elseif (reg == 0x4)
            {
                // 0x2004:
                // Sprite Memory read.
                return this._nes._ppu.SramLoad();
            }
            elseif (reg == 0x5)
            {
                return 0;
            }
            elseif (reg == 0x6)
            {
                return 0;
            }
            elseif (reg == 0x7)
            {
                // 0x2007:
                // VRAM read:
                return this._nes._ppu.VramLoad();
            }
        }
        // Sound+Joypad registers
        elseif (type == 4)
        {
            var reg = address - 0x4015;
            if (reg == 0)
            {
                // 0x4015:
                // Sound channel enable, DMC Status
                return this._nes._papu.ReadReg(address);
            }
            elseif (reg == 1)
            {
                // 0x4016:
                // Joystick 1 + Strobe
                return this.Joy1Read();
            }
            elseif (reg == 2)
            {
                // 0x4017:
                // Joystick 2 + Strobe
                // https://wiki.nesdev.com/w/index.php/Zapper
                var w = 0;

                if (this._zapper_x != null && this._zapper_y != null && this._nes._ppu.IsPixelWhite(this._zapper_x, this._zapper_y)) {
            		w = 0;
                } else {
                    w = 0x1 <<- 3;
                }

                if (this._zapper_fired) {
                    w = w | 0x1 <<- 4;
                }
                return (this.Joy2Read() | w) & 0xffff;
            }
        }

        return 0;
    }

    public fun RegWrite(int address, int value)
    {
        if (address == 0x2000)
        {
            // PPU Control register 1
            this._nes._cpu._mem[address] = value;
            this._nes._ppu.UpdateControlReg1(value);
        }
        elseif (address == 0x2001)
        {
            // PPU Control register 2
            this._nes._cpu._mem[address] = value;
            this._nes._ppu.UpdateControlReg2(value);
        }
        elseif (address == 0x2003)
        {
            // Set Sprite RAM address:
            this._nes._ppu.WriteSRAMAddress(value);
        }
        elseif (address == 0x2004)
        {
            // Write to Sprite RAM:
            this._nes._ppu.SramWrite(value);
        }
        elseif (address == 0x2005)
        {
            // Screen Scroll offsets:
            this._nes._ppu.ScrollWrite(value);
        }
        elseif (address == 0x2006)
        {
            // Set VRAM address:
            this._nes._ppu.WriteVRAMAddress(value);
        }
        elseif (address == 0x2007)
        {
            // Write to VRAM:
            this._nes._ppu.VramWrite(value);
        }
        elseif (address == 0x4014)
        {
            // Sprite Memory DMA Access
            this._nes._ppu.SramDMA(value);
        }
        elseif (address == 0x4015)
        {
            // Sound Channel Switch, DMC Status
            this._nes._papu.WriteReg(address, value);
        }
        elseif (address == 0x4016)
        {
            // Joystick 1 + Strobe
            if ((value & 1) == 0 && (this._joypad_strobe_state & 1) == 1) {
                this._joy1_strobe_state = 0;
                this._joy2_strobe_state = 0;
        	}
        	this._joypad_strobe_state = value;
        }
        elseif (address == 0x4017)
        {
            // Sound channel frame sequencer:
            this._nes._papu.WriteReg(address, value);
        }
        else
        {
            // Sound registers
            // console.log("write to sound reg");
            if (address >= 0x4000 && address <= 0x4017) {
                this._nes._papu.WriteReg(address, value);
            }
        }
    }

    public fun Joy1Read() : int
    {
        var ret = 0;

        if (this._joy1_strobe_state >= 0 && this._joy1_strobe_state <= 7)
        	ret = this._nes._controllers[1]._state[this._joy1_strobe_state];
        elseif (this._joy1_strobe_state >= 8 && this._joy1_strobe_state <= 18)
        	ret = 0;
        elseif (this._joy1_strobe_state == 19)
        	ret = 1;
        else
        	ret = 0;

		++this._joy1_strobe_state;
		if (this._joy1_strobe_state == 24) {
			this._joy1_strobe_state = 0;
		}

		return ret;
    }

    public fun Joy2Read() : int
    {
        var ret = 0;

        if (this._joy2_strobe_state >= 0 && this._joy2_strobe_state <= 7) 
        	ret = this._nes._controllers[2]._state[this._joy2_strobe_state];
        elseif (this._joy2_strobe_state >= 8 && this._joy2_strobe_state <= 18)
        	ret = 0;
        elseif (this._joy2_strobe_state == 19)
        	ret = 1;
        else
	        ret = 0;

        ++this._joy2_strobe_state;
		if (this._joy2_strobe_state == 24) {
			this._joy2_strobe_state = 0;
		}

		return ret;
    }

    public fun LoadROM() : string
    {
        if (!this._nes._rom._valid || this._nes._rom._rom_count < 1) {
            return "NoMapper: Invalid ROM! Unable to load.";
        }

        // Load ROM into memory:
        this.LoadPRGROM();

        // Load CHR-ROM:
        this.LoadCHRROM();

        // Load Battery RAM (if present):
        this.LoadBatteryRam();

        // Reset IRQ:
        this._nes._cpu.RequestIrq(NesCPUIRQ.IRQ_RESET);

        return null;
    }

    public fun LoadPRGROM()
    {
        if (this._nes._rom._rom_count > 1) {
            // Load the two first banks into memory.
            this.LoadRomBank(0, 0x8000);
            this.LoadRomBank(1, 0xc000);
        } else {
            // Load the one bank into both memory locations:
            this.LoadRomBank(0, 0x8000);
            this.LoadRomBank(0, 0xc000);
        }
    }

    public fun LoadCHRROM()
    {
        // console.log("Loading CHR ROM..");
        if (this._nes._rom._vrom_count > 0) {
            if (this._nes._rom._vrom_count == 1) {
                this.LoadVromBank(0, 0x0000);
                this.LoadVromBank(0, 0x1000);
            } else {
                this.LoadVromBank(0, 0x0000);
                this.LoadVromBank(1, 0x1000);
            }
        } else {
            //System.out.println("There aren't any CHR-ROM banks..");
        }
    }

    public fun LoadBatteryRam()
    {
        if (this._nes._rom._battery_ram != null) {
            var ram = this._nes._rom._battery_ram;
            if (ram != null && this._nes._rom._battery_ram_len == 0x2000) {
                // Load Battery RAM into memory:
                CopyArrayElements(ram, 0, this._nes._cpu._mem, 0x6000, 0x2000);
            }
        }
    }

    public fun LoadRomBank(int bank, int address)
    {
        // Loads a ROM bank into the specified address.
        bank %= this._nes._rom._rom_count;
        //var data = this._nes._rom.rom[bank];
        //cpuMem.write(address,data,data.length);
        CopyArrayElements(
                           this._nes._rom._rom[bank],
                           0,
                           this._nes._cpu._mem,
                           address,
                           16384
                           );
    }

    public fun LoadVromBank(int bank, int address)
    {
        if (this._nes._rom._vrom_count == 0) {
            return;
        }
        this._nes._ppu.TriggerRendering();

        CopyArrayElements(this._nes._rom._vrom[bank % this._nes._rom._vrom_count],
                       0,
                       this._nes._ppu._vram_mem,
                       address,
                       4096
                       );

        var vrom_tile = this._nes._rom._vrom_tile[bank % this._nes._rom._vrom_count];
        CopyArrayElements(vrom_tile,
                       0,
                       this._nes._ppu._pt_tile,
                       address ->> 4,
                       256
                       );
    }

    public fun Load32kRomBank(int bank, int address)
    {
        this.LoadRomBank((bank * 2) % this._nes._rom._rom_count, address);
        this.LoadRomBank((bank * 2 + 1) % this._nes._rom._rom_count, address + 16384);
    }

    public fun Load8kVromBank(int bank4kStart, int address)
    {
        if (this._nes._rom._vrom_count == 0) {
            return;
        }
        this._nes._ppu.TriggerRendering();

        this.LoadVromBank(bank4kStart % this._nes._rom._vrom_count, address);
        this.LoadVromBank((bank4kStart + 1) % this._nes._rom._vrom_count, address + 4096);
    }

    public fun Load1kVromBank(int bank1k, int address)
    {
        if (this._nes._rom._vrom_count == 0) {
            return;
        }
        this._nes._ppu.TriggerRendering();

        var bank4k = ALittle.Math_Floor(bank1k / 4) % this._nes._rom._vrom_count;
        var bankoffset = (bank1k % 4) * 1024;
        CopyArrayElements(this._nes._rom._vrom[bank4k],
                       bankoffset,
                       this._nes._ppu._vram_mem,
                       address,
                       1024
                       );

        // Update tiles:
        var vromTile = this._nes._rom._vrom_tile[bank4k];
        var baseIndex = address ->> 4;
        for (var i = 0; i < 64; 1) {
            this._nes._ppu._pt_tile[baseIndex + i] = vromTile[(bank1k % 4 <<- 6) + i];
        }
    }

    public fun Load2kVromBank(int bank2k, int address)
    {
        if (this._nes._rom._vrom_count == 0) {
            return;
        }
        this._nes._ppu.TriggerRendering();

        var bank4k = ALittle.Math_Floor(bank2k / 2) % this._nes._rom._vrom_count;
        var bankoffset = (bank2k % 2) * 2048;
        CopyArrayElements(this._nes._rom._vrom[bank4k],
                           bankoffset,
                           this._nes._ppu._vram_mem,
                           address,
                           2048
                           );

        // Update tiles:
        var vromTile = this._nes._rom._vrom_tile[bank4k];
        var baseIndex = address ->> 4;
        for (var i = 0; i < 128; 1) {
            this._nes._ppu._pt_tile[baseIndex + i] = vromTile[(bank2k % 2 <<- 7) + i];
        }
    }

    public fun Load8kRomBank(int bank8k, int address)
    {
        var bank16k = ALittle.Math_Floor(bank8k / 2) % this._nes._rom._rom_count;
        var offset = (bank8k % 2) * 8192;

        //this._nes._cpu._mem.write(address,this._nes._rom.rom[bank16k],offset,8192);
        CopyArrayElements(this._nes._rom._rom[bank16k],
                           offset,
                           this._nes._cpu._mem,
                           address,
                           8192
                           );
    }
}
