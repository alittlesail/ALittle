
namespace NESEmulator;

protected var CPU_FREQ_NTSC = 1789772.5;

protected class NesPAPU
{
    public NesCore _nes;

    private NesChannelSquare _square1;
    private NesChannelSquare _square2;
    private NesChannelTriangle _triangle;
    private NesChannelNoise _noise;
    private NesChannelDM _dmc;

    private int _frame_irq_counter;
    private int _frame_irq_counter_max;
    private int _init_counter;
    private int _channel_enable_value;

    private int _sample_rate;

    private Map<int, int> _length_lookup;
    private Map<int, int> _dmc_freq_lookup;
    private Map<int, int> _noise_wavelength_lookup;
    private Map<int, int> _square_table;
    private int _square_table_len;
    private Map<int, int> _tnd_table;
    private int _tnd_table_len;

    private bool _frame_irq_enabled;
    private bool _frame_irq_active;
    private int _frame_clock_now;
    private bool _started_playing;
    private bool _record_output;
    private bool _initing_hardware;

    private int _master_frame_counter;
    private int _derived_frame_counter;
    private int _count_sequence;
    private int _sample_timer;
    private int _frame_time;
    private int _sample_timer_max;
    private int _sample_count;
    private int _tri_value;

    private int _smp_square1;
    private int _smp_square2;
    private int _smp_triangle;
    private int _smp_dmc;
    private int _acc_count;

    // DC removal vars:
    private int _prev_sample_l;
    private int _prev_sample_r;
    private int _smp_accum_l;
    private int _smp_accum_r;

    // DAC range:
    private int _dac_range;
    private int _dac_value;

    // Master volume:
    private int _master_volume;

    // Stereo positioning:
    private int _stereo_pos_l_square1;
    private int _stereo_pos_l_square2;
    private int _stereo_pos_l_triangle;
    private int _stereo_pos_l_noise;
    private int _stereo_pos_l_dmc;
    private int _stereo_pos_r_square1;
    private int _stereo_pos_r_square2;
    private int _stereo_pos_r_triangle;
    private int _stereo_pos_r_noise;
    private int _stereo_pos_r_dmc;

    private int _extra_cycles;

    private int _max_sample;
    private int _min_sample;

    private Map<int, int> _panning;

    public ctor(NesCore nes)
    {
        this._nes = nes;

        this._square1 = new NesChannelSquare(this, true);
        this._square2 = new NesChannelSquare(this, false);
        this._triangle = new NesChannelTriangle(this);
        this._noise = new NesChannelNoise(this);
        this._dmc = new NesChannelDM(this);

        this._frame_irq_counter = null;
        this._frame_irq_counter_max = 4;
        this._init_counter = 2048;
        this._channel_enable_value = null;

        this._sample_rate = 44100;

        this._length_lookup = null;
        this._dmc_freq_lookup = null;
        this._noise_wavelength_lookup = null;
        this._square_table = null;
        this._tnd_table = null;
        this._square_table_len = 32 * 16;
        this._tnd_table_len = 204 * 16;

        this._frame_irq_enabled = false;
        this._frame_irq_active = null;
        this._frame_clock_now = null;
        this._started_playing = false;
        this._record_output = false;
        this._initing_hardware = false;

        this._master_frame_counter = null;
        this._derived_frame_counter = null;
        this._count_sequence = null;
        this._sample_timer = null;
        this._frame_time = null;
        this._sample_timer_max = null;
        this._sample_count = null;
        this._tri_value = 0;

        this._smp_square1 = null;
        this._smp_square2 = null;
        this._smp_triangle = null;
        this._smp_dmc = null;
        this._acc_count = null;

        // DC removal vars:
        this._prev_sample_l = 0;
        this._prev_sample_r = 0;
        this._smp_accum_l = 0;
        this._smp_accum_r = 0;

        // DAC range:
        this._dac_range = 0;
        this._dac_value = 0;

        // Master volume:
        this._master_volume = 256;

        // Stereo positioning:
        this._stereo_pos_l_square1 = null;
        this._stereo_pos_l_square2 = null;
        this._stereo_pos_l_triangle = null;
        this._stereo_pos_l_noise = null;
        this._stereo_pos_l_dmc = null;
        this._stereo_pos_r_square1 = null;
        this._stereo_pos_r_square2 = null;
        this._stereo_pos_r_triangle = null;
        this._stereo_pos_r_noise = null;
        this._stereo_pos_r_dmc = null;

        this._extra_cycles = 0;

        this._max_sample = null;
        this._min_sample = null;

        // Panning:
        var values = [80, 170, 100, 150, 128];
        this._panning = new Map<int, int>();
        for (var index, value in values)
            this._panning[index - 1] = value;
        this.SetPanning(this._panning);

        // Initialize lookup tables:
        this.InitLengthLookup();
        this.InitDmcFrequencyLookup();
        this.InitNoiseWavelengthLookup();
        this.InitDACtables();

        // Init sound registers:
        for (var i = 0; i < 0x14; 1) {
            if (i == 0x10) {
                this.WriteReg(0x4010, 0x10);
            } else {
                this.WriteReg(0x4000 + i, 0);
            }
        }

        this.Reset();
    }

    public fun Reset()
    {
        this._sample_rate = this._nes._sample_rate;
        this._sample_timer_max = ALittle.Math_Floor((1024.0 * CPU_FREQ_NTSC * this._nes._preferred_frame_rate) / (this._sample_rate * 60.0));
        this._frame_time = ALittle.Math_Floor((14915.0 * this._nes._preferred_frame_rate) / 60.0);

        this._sample_timer = 0;

        this.UpdateChannelEnable(0);
        this._master_frame_counter = 0;
        this._derived_frame_counter = 0;
        this._count_sequence = 0;
        this._sample_count = 0;
        this._init_counter = 2048;
        this._frame_irq_enabled = false;
        this._initing_hardware = false;

        this.ResetCounter();

        this._square1.Reset();
        this._square2.Reset();
        this._triangle.Reset();
        this._noise.Reset();
        this._dmc.Reset();

        this._acc_count = 0;
        this._smp_square1 = 0;
        this._smp_square2 = 0;
        this._smp_triangle = 0;
        this._smp_dmc = 0;

        this._frame_irq_enabled = false;
        this._frame_irq_counter_max = 4;

        this._channel_enable_value = 0xff;
        this._started_playing = false;
        this._prev_sample_l = 0;
        this._prev_sample_r = 0;
        this._smp_accum_l = 0;
        this._smp_accum_r = 0;

        this._max_sample = -500000;
        this._min_sample = 500000;
    }

    // eslint-disable-next-line no-unused-vars
    public fun ReadReg(int address) : int
    {
        // Read 0x4015:
        var tmp = 0;
        tmp = tmp | this._square1.GetLengthStatus();
        tmp = tmp | (this._square2.GetLengthStatus() <<- 1);
        tmp = tmp | (this._triangle.GetLengthStatus() <<- 2);
        tmp = tmp | (this._noise.GetLengthStatus() <<- 3);
        tmp = tmp | (this._dmc.GetLengthStatus() <<- 4);
        tmp = tmp | (ConditionExpr(this._frame_irq_active && this._frame_irq_enabled, 1, 0)) <<- 6;
        tmp = tmp | (this._dmc.GetIrqStatus() <<- 7);

        this._frame_irq_active = false;
        this._dmc._irq_generated = false;

        return tmp & 0xffff;
    }

    public fun WriteReg(int address, int value)
    {
        if (address >= 0x4000 && address < 0x4004) {
            // Square Wave 1 Control
            this._square1.WriteReg(address, value);
            // console.log("Square Write");
        } else if (address >= 0x4004 && address < 0x4008) {
            // Square 2 Control
            this._square2.WriteReg(address, value);
        } else if (address >= 0x4008 && address < 0x400c) {
            // Triangle Control
            this._triangle.WriteReg(address, value);
        } else if (address >= 0x400c && address <= 0x400f) {
            // Noise Control
            this._noise.WriteReg(address, value);
        } else if (address == 0x4010) {
            // DMC Play mode & DMA frequency
            this._dmc.WriteReg(address, value);
        } else if (address == 0x4011) {
            // DMC Delta Counter
            this._dmc.WriteReg(address, value);
        } else if (address == 0x4012) {
            // DMC Play code starting address
            this._dmc.WriteReg(address, value);
        } else if (address == 0x4013) {
            // DMC Play code length
            this._dmc.WriteReg(address, value);
        } else if (address == 0x4015) {
            // Channel enable
            this.UpdateChannelEnable(value);

            if (value != 0 && this._init_counter > 0) {
                // Start hardware initialization
                this._initing_hardware = true;
            }

                // DMC/IRQ Status
            this._dmc.WriteReg(address, value);
        } else if (address == 0x4017) {
            // Frame counter control
            this._count_sequence = (value ->> 7) & 1;
            this._master_frame_counter = 0;
            this._frame_irq_active = false;

            if (((value ->> 6) & 0x1) == 0) {
                this._frame_irq_enabled = true;
            } else {
                this._frame_irq_enabled = false;
            }

            if (this._count_sequence == 0) {
                // NTSC:
                this._frame_irq_counter_max = 4;
                this._derived_frame_counter = 4;
            } else {
                // PAL:
                this._frame_irq_counter_max = 5;
                this._derived_frame_counter = 0;
                this.FrameCounterTick();
            }
        }
    }

    public fun ResetCounter()
    {
        if (this._count_sequence == 0) {
            this._derived_frame_counter = 4;
        } else {
            this._derived_frame_counter = 0;
        }
    }

    // Updates channel enable status.
    // This is done on writes to the
    // channel enable register (0x4015),
    // and when the user enables/disables channels
    // in the GUI.
    public fun UpdateChannelEnable(int value)
    {
        this._channel_enable_value = value & 0xffff;
        this._square1.SetEnabled((value & 1) != 0);
        this._square2.SetEnabled((value & 2) != 0);
        this._triangle.SetEnabled((value & 4) != 0);
        this._noise.SetEnabled((value & 8) != 0);
        this._dmc.SetEnabled((value & 16) != 0);
    }

    // Clocks the frame counter. It should be clocked at
    // twice the cpu speed, so the cycles will be
    // divided by 2 for those counters that are
    // clocked at cpu speed.
    public fun ClockFrameCounter(int cycles)
    {
        if (this._init_counter > 0) {
            if (this._initing_hardware) {
                this._init_counter -= cycles;
                if (this._init_counter <= 0) {
                    this._initing_hardware = false;
                }
                return;
            }
        }

            // Don't process ticks beyond next sampling:
        cycles += this._extra_cycles;
        var maxCycles = this._sample_timer_max - this._sample_timer;
        if (cycles <<- 10 > maxCycles) {
            this._extra_cycles = ((cycles <<- 10) - maxCycles) ->> 10;
            cycles -= this._extra_cycles;
        } else {
            this._extra_cycles = 0;
        }

        var dmc = this._dmc;
        var triangle = this._triangle;
        var square1 = this._square1;
        var square2 = this._square2;
        var noise = this._noise;

        // Clock DMC:
        if (dmc._is_enabled) {
            dmc._shift_counter -= cycles <<- 3;
            while (dmc._shift_counter <= 0 && dmc._dma_frequency > 0) {
                dmc._shift_counter += dmc._dma_frequency;
                dmc.ClockDmc();
            }
        }

            // Clock Triangle channel Prog timer:
        if (triangle._prog_timer_max > 0) {
            triangle._prog_timer_count -= cycles;
            while (triangle._prog_timer_count <= 0) {
                triangle._prog_timer_count += triangle._prog_timer_max + 1;
                if (triangle._linear_counter > 0 && triangle._length_counter > 0) {
                    ++triangle._triangle_counter;
                    triangle._triangle_counter = triangle._triangle_counter & 0x1f;

                    if (triangle._is_enabled) {
                        if (triangle._triangle_counter >= 0x10) {
                            // Normal value.
                            triangle._sample_value = triangle._triangle_counter & 0xf;
                        } else {
                            // Inverted value.
                            triangle._sample_value = 0xf - (triangle._triangle_counter & 0xf);
                        }
                        triangle._sample_value = triangle._sample_value <<- 4;
                    }
                }
            }
        }

            // Clock Square channel 1 Prog timer:
        square1._prog_timer_count -= cycles;
        if (square1._prog_timer_count <= 0) {
            square1._prog_timer_count += (square1._prog_timer_max + 1) <<- 1;

            ++square1._square_counter;
            square1._square_counter = square1._square_counter & 0x7;
            square1.UpdateSampleValue();
        }

        // Clock Square channel 2 Prog timer:
        square2._prog_timer_count -= cycles;
        if (square2._prog_timer_count <= 0) {
            square2._prog_timer_count += (square2._prog_timer_max + 1) <<- 1;

            ++square2._square_counter;
            square2._square_counter = square2._square_counter & 0x7;
            square2.UpdateSampleValue();
        }

            // Clock noise channel Prog timer:
        var acc_c = cycles;
        if (noise._prog_timer_count - acc_c > 0) {
            // Do all cycles at once:
            noise._prog_timer_count -= acc_c;
            noise._acc_count += acc_c;
            noise._acc_value += acc_c * noise._sample_value;
        } else {
            // Slow-step:
            while (acc_c > 0) {
                --acc_c;
                --noise._prog_timer_count;
                if (noise._prog_timer_count <= 0 && noise._prog_timer_max > 0) {
                    // Update noise shift register:
                    noise._shift_reg = noise._shift_reg <<- 1;
                    noise._tmp = ((noise._shift_reg <<- ConditionExpr(noise._random_mode == 0, 1, 6)) ^ noise._shift_reg) & 0x8000;
                    if (noise._tmp != 0) {
                        // Sample value must be 0.
                        noise._shift_reg = noise._shift_reg | 0x01;
                        noise._random_bit = 0;
                        noise._sample_value = 0;
                    } else {
                        // Find sample value:
                        noise._random_bit = 1;
                        if (noise._is_enabled && noise._length_counter > 0) {
                            noise._sample_value = noise._master_volume;
                        } else {
                            noise._sample_value = 0;
                        }
                    }

                    noise._prog_timer_count += noise._prog_timer_max;
                }

                noise._acc_value += noise._sample_value;
                ++noise._acc_count;
            }
        }

        // Frame IRQ handling:
        if (this._frame_irq_enabled && this._frame_irq_active) {
            this._nes._cpu.RequestIrq(NesCPUIRQ.IRQ_NORMAL);
        }

        // Clock frame counter at double CPU speed:
        this._master_frame_counter += cycles <<- 1;
        if (this._master_frame_counter >= this._frame_time) {
            // 240Hz tick:
            this._master_frame_counter -= this._frame_time;
            this.FrameCounterTick();
        }

        // Accumulate sample value:
        this.AccSample(cycles);

        // Clock sample timer:
        this._sample_timer += cycles <<- 10;
        if (this._sample_timer >= this._sample_timer_max) {
            // Sample channels:
            this.Sample();
            this._sample_timer -= this._sample_timer_max;
        }
    }

    public fun AccSample(int cycles)
    {
        // Special treatment for triangle channel - need to interpolate.
        if (this._triangle._sample_condition) {
            this._tri_value = ALittle.Math_Floor((this._triangle._prog_timer_count <<- 4) / (this._triangle._prog_timer_max + 1));
            if (this._tri_value > 16) {
                this._tri_value = 16;
            }
            if (this._triangle._triangle_counter >= 16) {
                this._tri_value = 16 - this._tri_value;
            }

            // Add non-interpolated sample value:
            this._tri_value += this._triangle._sample_value;
        }

        // Now sample normally:
        if (cycles == 2) {
            this._smp_triangle += this._tri_value <<- 1;
            this._smp_dmc += this._dmc._sample <<- 1;
            this._smp_square1 += this._square1._sample_value <<- 1;
            this._smp_square2 += this._square2._sample_value <<- 1;
            this._acc_count += 2;
        } else if (cycles == 4) {
            this._smp_triangle += this._tri_value <<- 2;
            this._smp_dmc += this._dmc._sample <<- 2;
            this._smp_square1 += this._square1._sample_value <<- 2;
            this._smp_square2 += this._square2._sample_value <<- 2;
            this._acc_count += 4;
        } else {
            this._smp_triangle += cycles * this._tri_value;
            this._smp_dmc += cycles * this._dmc._sample;
            this._smp_square1 += cycles * this._square1._sample_value;
            this._smp_square2 += cycles * this._square2._sample_value;
            this._acc_count += cycles;
        }
    }

    public fun FrameCounterTick()
    {
        ++this._derived_frame_counter;
        if (this._derived_frame_counter >= this._frame_irq_counter_max) {
            this._derived_frame_counter = 0;
        }

        if (this._derived_frame_counter == 1 || this._derived_frame_counter == 3) {
            // Clock length & sweep:
            this._triangle.ClockLengthCounter();
            this._square1.ClockLengthCounter();
            this._square2.ClockLengthCounter();
            this._noise.ClockLengthCounter();
            this._square1.ClockSweep();
            this._square2.ClockSweep();
        }

        if (this._derived_frame_counter >= 0 && this._derived_frame_counter < 4) {
            // Clock linear & decay:
            this._square1.ClockEnvDecay();
            this._square2.ClockEnvDecay();
            this._noise.ClockEnvDecay();
            this._triangle.ClockLinearCounter();
        }

        if (this._derived_frame_counter == 3 && this._count_sequence == 0) {
            // Enable IRQ:
            this._frame_irq_active = true;
        }

        // End of 240Hz tick
    }

    // Samples the channels, mixes the output together, then writes to buffer.
    public fun Sample()
    {
        if (this._acc_count > 0) {
            this._smp_square1 = this._smp_square1 <<- 4;
            this._smp_square1 = ALittle.Math_Floor(this._smp_square1 / this._acc_count);

            this._smp_square2 = this._smp_square2 <<- 4;
            this._smp_square2 = ALittle.Math_Floor(this._smp_square2 / this._acc_count);

            this._smp_triangle = ALittle.Math_Floor(this._smp_triangle / this._acc_count);

            this._smp_dmc = this._smp_dmc <<- 4;
            this._smp_dmc = ALittle.Math_Floor(this._smp_dmc / this._acc_count);

            this._acc_count = 0;
        } else {
            this._smp_square1 = this._square1._sample_value <<- 4;
            this._smp_square2 = this._square2._sample_value <<- 4;
            this._smp_triangle = this._triangle._sample_value;
            this._smp_dmc = this._dmc._sample <<- 4;
        }

        var smpNoise = ALittle.Math_Floor((this._noise._acc_value <<- 4) / this._noise._acc_count);
        this._noise._acc_value = smpNoise ->> 4;
        this._noise._acc_count = 1;

        // Stereo sound.

        // Left channel:
        var sq_index = (this._smp_square1 * this._stereo_pos_l_square1 + this._smp_square2 * this._stereo_pos_l_square2) ->> 8;
        var tnd_index = (3 * this._smp_triangle * this._stereo_pos_l_triangle + (smpNoise <<- 1) * this._stereo_pos_l_noise + this._smp_dmc * this._stereo_pos_l_dmc) ->> 8;
        if (sq_index >= this._square_table_len) {
            sq_index = this._square_table_len - 1;
        }
        if (tnd_index >= this._tnd_table_len) {
            tnd_index = this._tnd_table_len - 1;
        }
        var sampleValueL = this._square_table[sq_index] + this._tnd_table[tnd_index] - this._dac_value;

        // Right channel:
        sq_index = (this._smp_square1 * this._stereo_pos_r_square1 + this._smp_square2 * this._stereo_pos_r_square2) ->> 8;
        tnd_index = (3 * this._smp_triangle * this._stereo_pos_r_triangle + (smpNoise <<- 1) * this._stereo_pos_r_noise + this._smp_dmc * this._stereo_pos_r_dmc) ->> 8;
        if (sq_index >= this._square_table_len) {
            sq_index = this._square_table_len - 1;
        }
        if (tnd_index >= this._tnd_table_len) {
            tnd_index = this._tnd_table_len - 1;
        }
        var sampleValueR = this._square_table[sq_index] + this._tnd_table[tnd_index] - this._dac_value;

        // Remove DC from left channel:
        var smpDiffL = sampleValueL - this._prev_sample_l;
        this._prev_sample_l += smpDiffL;
        this._smp_accum_l += smpDiffL - (this._smp_accum_l ->> 10);
        sampleValueL = this._smp_accum_l;

        // Remove DC from right channel:
        var smpDiffR = sampleValueR - this._prev_sample_r;
        this._prev_sample_r += smpDiffR;
        this._smp_accum_r += smpDiffR - (this._smp_accum_r ->> 10);
        sampleValueR = this._smp_accum_r;

        // Write:
        if (sampleValueL > this._max_sample) {
            this._max_sample = sampleValueL;
        }
        if (sampleValueL < this._min_sample) {
            this._min_sample = sampleValueL;
        }

        this._nes.OnAudioSample(sampleValueL / 32768, sampleValueR / 32768);

        // Reset sampled values:
        this._smp_square1 = 0;
        this._smp_square2 = 0;
        this._smp_triangle = 0;
        this._smp_dmc = 0;
    }

    public fun GetLengthMax(int value) : int
    {
        return this._length_lookup[value ->> 3];
    }

    public fun GetDmcFrequency(int value) : int
    {
        if (value >= 0 && value < 0x10) {
            return this._dmc_freq_lookup[value];
        }
        return 0;
    }

    public fun GetNoiseWaveLength(int value) : int
    {
        if (value >= 0 && value < 0x10) {
            return this._noise_wavelength_lookup[value];
        }
        return 0;
    }

    public fun SetPanning(Map<int, int> pos)
    {
        for (var i = 0; i < 5; 1) {
            this._panning[i] = pos[i];
        }
        this.UpdateStereoPos();
    }

    public fun SetMasterVolume(int value)
    {
        if (value < 0) {
            value = 0;
        }
        if (value > 256) {
            value = 256;
        }
        this._master_volume = value;
        this.UpdateStereoPos();
    }

    public fun UpdateStereoPos()
    {
        this._stereo_pos_l_square1 = (this._panning[0] * this._master_volume) ->> 8;
        this._stereo_pos_l_square2 = (this._panning[1] * this._master_volume) ->> 8;
        this._stereo_pos_l_triangle = (this._panning[2] * this._master_volume) ->> 8;
        this._stereo_pos_l_noise = (this._panning[3] * this._master_volume) ->> 8;
        this._stereo_pos_l_dmc = (this._panning[4] * this._master_volume) ->> 8;

        this._stereo_pos_r_square1 = this._master_volume - this._stereo_pos_l_square1;
        this._stereo_pos_r_square2 = this._master_volume - this._stereo_pos_l_square2;
        this._stereo_pos_r_triangle = this._master_volume - this._stereo_pos_l_triangle;
        this._stereo_pos_r_noise = this._master_volume - this._stereo_pos_l_noise;
        this._stereo_pos_r_dmc = this._master_volume - this._stereo_pos_l_dmc;
    }

    public fun InitLengthLookup()
    {
        // prettier-ignore
        var values = [0x0A, 0xFE,
                      0x14, 0x02,
                      0x28, 0x04,
                      0x50, 0x06,
                      0xA0, 0x08,
                      0x3C, 0x0A,
                      0x0E, 0x0C,
                      0x1A, 0x0E,
                      0x0C, 0x10,
                      0x18, 0x12,
                      0x30, 0x14,
                      0x60, 0x16,
                      0xC0, 0x18,
                      0x48, 0x1A,
                      0x10, 0x1C,
                      0x20, 0x1E
                      ];

        this._length_lookup = new Map<int, int>();
        for (var index, value in values)
            this._length_lookup[index - 1] = value;
    }

    public fun InitDmcFrequencyLookup()
    {
        this._dmc_freq_lookup = new Map<int, int>();

        this._dmc_freq_lookup[0x0] = 0xd60;
        this._dmc_freq_lookup[0x1] = 0xbe0;
        this._dmc_freq_lookup[0x2] = 0xaa0;
        this._dmc_freq_lookup[0x3] = 0xa00;
        this._dmc_freq_lookup[0x4] = 0x8f0;
        this._dmc_freq_lookup[0x5] = 0x7f0;
        this._dmc_freq_lookup[0x6] = 0x710;
        this._dmc_freq_lookup[0x7] = 0x6b0;
        this._dmc_freq_lookup[0x8] = 0x5f0;
        this._dmc_freq_lookup[0x9] = 0x500;
        this._dmc_freq_lookup[0xa] = 0x470;
        this._dmc_freq_lookup[0xb] = 0x400;
        this._dmc_freq_lookup[0xc] = 0x350;
        this._dmc_freq_lookup[0xd] = 0x2a0;
        this._dmc_freq_lookup[0xe] = 0x240;
        this._dmc_freq_lookup[0xf] = 0x1b0;
        //for(int i=0;i<16;i++)dmcFreqLookup[i]/=8;
    }

    public fun InitNoiseWavelengthLookup()
    {
        this._noise_wavelength_lookup = new Map<int, int>();

        this._noise_wavelength_lookup[0x0] = 0x004;
        this._noise_wavelength_lookup[0x1] = 0x008;
        this._noise_wavelength_lookup[0x2] = 0x010;
        this._noise_wavelength_lookup[0x3] = 0x020;
        this._noise_wavelength_lookup[0x4] = 0x040;
        this._noise_wavelength_lookup[0x5] = 0x060;
        this._noise_wavelength_lookup[0x6] = 0x080;
        this._noise_wavelength_lookup[0x7] = 0x0a0;
        this._noise_wavelength_lookup[0x8] = 0x0ca;
        this._noise_wavelength_lookup[0x9] = 0x0fe;
        this._noise_wavelength_lookup[0xa] = 0x17c;
        this._noise_wavelength_lookup[0xb] = 0x1fc;
        this._noise_wavelength_lookup[0xc] = 0x2fa;
        this._noise_wavelength_lookup[0xd] = 0x3f8;
        this._noise_wavelength_lookup[0xe] = 0x7f2;
        this._noise_wavelength_lookup[0xf] = 0xfe4;
    }

    public fun InitDACtables()
    {
        var max_sqr = 0;
        var max_tnd = 0;

        this._square_table = new Map<int, int>();
        for (var i = 0; i < this._square_table_len; 1) {
            var value = 95.52 / (8128.0 / (i / 16.0) + 100.0);
            value *= 0.98411;
            value *= 50000.0;
            var ival = ALittle.Math_Floor(value);

            this._square_table[i] = ival;
            if (ival > max_sqr) {
                max_sqr = ival;
            }
        }

        this._tnd_table = new Map<int, int>();
        for (var i = 0; i < this._tnd_table_len; 1) {
            var value = 163.67 / (24329.0 / (i / 16.0) + 100.0);
            value *= 0.98411;
            value *= 50000.0;
            var ival = ALittle.Math_Floor(value);

            this._tnd_table[i] = ival;
            if (ival > max_tnd) {
                max_tnd = ival;
            }
        }

        this._dac_range = max_sqr + max_tnd;
        this._dac_value = ALittle.Math_Floor(this._dac_range / 2);
    }
}
