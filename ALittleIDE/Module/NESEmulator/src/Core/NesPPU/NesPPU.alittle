
namespace NESEmulator;

protected enum NesPPUStatus
{
    STATUS_VRAMWRITE = 4;
    STATUS_SLSPRITECOUNT = 5;
    STATUS_SPRITE0HIT = 6;
    STATUS_VBLANK = 7;
}

protected var SCREEN_WIDTH = 256;
protected var SCREEN_HEIGHT = 240;
protected var PIXEL_COUNT = SCREEN_WIDTH * SCREEN_HEIGHT;

protected class NesPPU
{
    private NesCore _nes;

    // 背景图片内存
    public Map<int, int> _vram_mem;
    // 精灵图片内存
    public Map<int, int> _sprite_mem;

    // VRAM I/O:
    private int _vram_address;
    private int _vram_tmp_address;
    private int _vram_buffered_read_value;
    private bool _first_write;

    // SPR-RAM I/O:
    private int _sram_address;
    private int _current_mirroring;
    public bool _request_end_frame;
    private bool _nmi_ok;
    private bool _dummy_cycle_toggle;
    private bool _valid_tile_data;
    public int _nmi_counter;
    private bool _scanline_already_rendered;

    // Control Flags Register 1:
    private int _f_nmi_on_vblank;
    private int _f_sprite_size;
    private int _f_bg_pattern_table;
    private int _f_sp_pattern_table;
    private int _f_addr_inc;
    private int _f_ntbl_address;

    // Control Flags Register 2:
    private int _f_color;
    public int _f_sp_visibility;
    private int _f_bg_visibility;
    private int _f_sp_clipping;
    private int _f_bg_clipping;
    private int _f_disp_type;

    // Counters:
    private int _cnt_fv;
    private int _cnt_v;
    private int _cnt_h;
    private int _cnt_vt;
    private int _cnt_ht;

    private int _cur_nt;

    // Registers:
    private int _reg_fv;
    private int _reg_v;
    private int _reg_h;
    private int _reg_vt;
    private int _reg_ht;
    private int _reg_fh;
    private int _reg_s;

    // Variables used when rendering:
    private Map<int, int> _attrib;
    private Map<int, int> _buffer;
    private Map<int, int> _bgbuffer;
    private Map<int, int> _pixrendered;
    private Map<int, NesTile> _scantile;

    // Initialize misc vars:
    public int _scanline;
    private int _last_rendered_scanline;
    public int _cur_x;

    // Sprite data:
    private Map<int, int> _spr_x;
    private Map<int, int> _spr_y;
    private Map<int, int> _spr_tile;
    private Map<int, int> _spr_col;
    private Map<int, bool> _vert_flip;
    private Map<int, bool> _hori_flip;
    private Map<int, bool> _bg_priority;
    public int _spr_0_hit_x;
    public int _spr_0_hit_y;
    private bool _hit_spr_0;
    private bool _show_spr_0_hit;
    private bool _clip_to_tv_size;

    // Palette data:
    private Map<int, int> _spr_palette;
    private Map<int, int> _img_palette;

    // Create pattern table tile buffers:
    public Map<int, NesTile> _pt_tile;

    // Create nametable buffers:
    // Name table data:
    private Map<int, int> _ntable_1;
    private Map<int, NesNameTable> _name_table;

    // Initialize mirroring lookup table:
    private Map<int, int> _vram_mirror_table;

    private NesPaletteTable _pal_table;

    public ctor(NesCore nes)
    {
        this._nes = nes;
    }

    public fun Reset()
    {
        // Memory
        this._vram_mem = new Map<int, int>();
        for (var i = 0; i < 0x8000; 1) {
            this._vram_mem[i] = 0;
        }
        this._sprite_mem = new Map<int, int>();
        for (var i = 0; i < 0x100; 1) {
            this._sprite_mem[i] = 0;
        }

        // VRAM I/O:
        this._vram_address = null;
        this._vram_tmp_address = null;
        this._vram_buffered_read_value = 0;
        this._first_write = true; // VRAM/Scroll Hi/Lo latch

        // SPR-RAM I/O:
        this._sram_address = 0; // 8-bit only.

        this._current_mirroring = -1;
        this._request_end_frame = false;
        this._nmi_ok = false;
        this._dummy_cycle_toggle = false;
        this._valid_tile_data = false;
        this._nmi_counter = 0;
        this._scanline_already_rendered = null;

        // Control Flags Register 1:
        this._f_nmi_on_vblank = 0; // NMI on VBlank. 0=disable, 1=enable
        this._f_sprite_size = 0; // Sprite size. 0=8x8, 1=8x16
        this._f_bg_pattern_table = 0; // Background Pattern Table address. 0=0x0000,1=0x1000
        this._f_sp_pattern_table = 0; // Sprite Pattern Table address. 0=0x0000,1=0x1000
        this._f_addr_inc = 0; // PPU Address Increment. 0=1,1=32
        this._f_ntbl_address = 0; // Name Table Address. 0=0x2000,1=0x2400,2=0x2800,3=0x2C00

        // Control Flags Register 2:
        this._f_color = 0; // Background color. 0=black, 1=blue, 2=green, 4=red
        this._f_sp_visibility = 0; // Sprite visibility. 0=not displayed,1=displayed
        this._f_bg_visibility = 0; // Background visibility. 0=Not Displayed,1=displayed
        this._f_sp_clipping = 0; // Sprite clipping. 0=Sprites invisible in left 8-pixel column,1=No clipping
        this._f_bg_clipping = 0; // Background clipping. 0=BG invisible in left 8-pixel column, 1=No clipping
        this._f_disp_type = 0; // Display type. 0=color, 1=monochrome

        // Counters:
        this._cnt_fv = 0;
        this._cnt_v = 0;
        this._cnt_h = 0;
        this._cnt_vt = 0;
        this._cnt_ht = 0;

        // Registers:
        this._reg_fv = 0;
        this._reg_v = 0;
        this._reg_h = 0;
        this._reg_vt = 0;
        this._reg_ht = 0;
        this._reg_fh = 0;
        this._reg_s = 0;

        // These are temporary variables used in rendering and sound procedures.
        // Their states outside of those procedures can be ignored.
        // TODO: the use of this is a bit weird, investigate
        this._cur_nt = null;

        // Variables used when rendering:
        this._attrib = new Map<int, int>();
        this._buffer = new Map<int, int>();
        this._bgbuffer = new Map<int, int>();
        this._pixrendered = new Map<int, int>();

        this._valid_tile_data = null;

        this._scantile = new Map<int, NesTile>();

        // Initialize misc vars:
        this._scanline = 0;
        this._last_rendered_scanline = -1;
        this._cur_x = 0;

        // Sprite data:
        this._spr_x = new Map<int, int>(); // X coordinate
        this._spr_y = new Map<int, int>(); // Y coordinate
        this._spr_tile = new Map<int, int>(); // Tile Index (into pattern table)
        this._spr_col = new Map<int, int>(); // Upper two bits of color
        this._vert_flip = new Map<int, bool>(); // Vertical Flip
        this._hori_flip = new Map<int, bool>(); // Horizontal Flip
        this._bg_priority = new Map<int, bool>(); // Background priority
        this._spr_0_hit_x = 0; // Sprite #0 hit X coordinate
        this._spr_0_hit_y = 0; // Sprite #0 hit Y coordinate
        this._hit_spr_0 = false;

        // Palette data:
        this._spr_palette = new Map<int, int>();
        this._img_palette = new Map<int, int>();

        // Create pattern table tile buffers:
        this._pt_tile = new Map<int, NesTile>();
        for (var i = 0; i < 512; 1) {
            this._pt_tile[i] = new NesTile();
        }

        // Create nametable buffers:
        // Name table data:
        this._ntable_1 = new Map<int, int>();
        this._current_mirroring = -1;
        this._name_table = new Map<int, NesNameTable>();
        for (var i = 0; i < 4; 1)
            this._name_table[i] = new NesNameTable(32, 32, "Nt"..i);

        // Initialize mirroring lookup table:
        this._vram_mirror_table = new Map<int, int>();
        for (var i = 0; i < 0x8000; 1) {
            this._vram_mirror_table[i] = i;
        }

        this._pal_table = new NesPaletteTable();
        this._pal_table.LoadNTSCPalette();
        //this.pal_table.loadDefaultPalette();

        this.UpdateControlReg1(0);
        this.UpdateControlReg2(0);
    }

    // Sets Nametable mirroring.
    public fun SetMirroring(int mirroring)
    {
        if (mirroring == this._current_mirroring) {
            return;
        }

        this._current_mirroring = mirroring;
        this.TriggerRendering();

        // Remove mirroring:
        if (this._vram_mirror_table == null) {
            this._vram_mirror_table = new Map<int, int>();
        }
        for (var i = 0; i < 0x8000; 1) {
            this._vram_mirror_table[i] = i;
        }

        // Palette mirroring:
        this.DefineMirrorRegion(0x3f20, 0x3f00, 0x20);
        this.DefineMirrorRegion(0x3f40, 0x3f00, 0x20);
        this.DefineMirrorRegion(0x3f80, 0x3f00, 0x20);
        this.DefineMirrorRegion(0x3fc0, 0x3f00, 0x20);

        // Additional mirroring:
        this.DefineMirrorRegion(0x3000, 0x2000, 0xf00);
        this.DefineMirrorRegion(0x4000, 0x0000, 0x4000);

        if (mirroring == NESMirroringType.HORIZONTAL_MIRRORING) {
            // Horizontal mirroring.

            this._ntable_1[0] = 0;
            this._ntable_1[1] = 0;
            this._ntable_1[2] = 1;
            this._ntable_1[3] = 1;

            this.DefineMirrorRegion(0x2400, 0x2000, 0x400);
            this.DefineMirrorRegion(0x2c00, 0x2800, 0x400);
        } else if (mirroring == NESMirroringType.VERTICAL_MIRRORING) {
            // Vertical mirroring.

            this._ntable_1[0] = 0;
            this._ntable_1[1] = 1;
            this._ntable_1[2] = 0;
            this._ntable_1[3] = 1;

            this.DefineMirrorRegion(0x2800, 0x2000, 0x400);
            this.DefineMirrorRegion(0x2c00, 0x2400, 0x400);
        } else if (mirroring == NESMirroringType.SINGLESCREEN_MIRRORING) {
            // Single Screen mirroring

            this._ntable_1[0] = 0;
            this._ntable_1[1] = 0;
            this._ntable_1[2] = 0;
            this._ntable_1[3] = 0;

            this.DefineMirrorRegion(0x2400, 0x2000, 0x400);
            this.DefineMirrorRegion(0x2800, 0x2000, 0x400);
            this.DefineMirrorRegion(0x2c00, 0x2000, 0x400);
        } else if (mirroring == NESMirroringType.SINGLESCREEN_MIRRORING2) {
            this._ntable_1[0] = 1;
            this._ntable_1[1] = 1;
            this._ntable_1[2] = 1;
            this._ntable_1[3] = 1;

            this.DefineMirrorRegion(0x2400, 0x2400, 0x400);
            this.DefineMirrorRegion(0x2800, 0x2400, 0x400);
            this.DefineMirrorRegion(0x2c00, 0x2400, 0x400);
        } else {
            // Assume Four-screen mirroring.

            this._ntable_1[0] = 0;
            this._ntable_1[1] = 1;
            this._ntable_1[2] = 2;
            this._ntable_1[3] = 3;
        }
    }

    // Define a mirrored area in the address lookup table.
    // Assumes the regions don't overlap.
    // The 'to' region is the region that is physically in memory.
    public fun DefineMirrorRegion(int fromStart, int toStart, int size)
    {
        for (var i = 0; i < size; 1)
            this._vram_mirror_table[fromStart + i] = toStart + i;
    }

    public fun StartVBlank()
    {
        // Do NMI:
        this._nes._cpu.RequestIrq(NesCPUIRQ.IRQ_NMI);

        // Make sure everything is rendered:
        if (this._last_rendered_scanline < 239) {
            this.RenderFramePartially(this._last_rendered_scanline + 1, 240 - this._last_rendered_scanline);
        }

        // End frame:
        this.EndFrame();

        // Reset scanline counter:
        this._last_rendered_scanline = -1;
    }

    public fun EndScanline()
    {
        if (this._scanline == 19)
        {
            // Dummy scanline.
            // May be variable length:
            if (this._dummy_cycle_toggle) {
                // Remove dead cycle at end of scanline,
                // for next scanline:
                this._cur_x = 1;
                this._dummy_cycle_toggle = !this._dummy_cycle_toggle;
            }
        }
        elseif (this._scanline == 20)
        {
            // Clear VBlank flag:
            this.SetStatusFlag(NesPPUStatus.STATUS_VBLANK, false);

            // Clear Sprite #0 hit flag:
            this.SetStatusFlag(NesPPUStatus.STATUS_SPRITE0HIT, false);
            this._hit_spr_0 = false;
            this._spr_0_hit_x = -1;
            this._spr_0_hit_y = -1;

            if (this._f_bg_visibility == 1 || this._f_sp_visibility == 1) {
                // Update counters:
                this._cnt_fv = this._reg_fv;
                this._cnt_v = this._reg_v;
                this._cnt_h = this._reg_h;
                this._cnt_vt = this._reg_vt;
                this._cnt_ht = this._reg_ht;

                if (this._f_bg_visibility == 1) {
                    // Render dummy scanline:
                    this.RenderBgScanline(false, 0);
                }
            }

            if (this._f_bg_visibility == 1 && this._f_sp_visibility == 1) {
                // Check sprite 0 hit for first scanline:
                this.CheckSprite0(0);
            }

            if (this._f_bg_visibility == 1 || this._f_sp_visibility == 1) {
                // Clock mapper IRQ Counter:
                this._nes._mmap.ClockIrqCounter();
            }
        }
        elseif (this._scanline == 261)
        {
            // Dead scanline, no rendering.
            // Set VINT:
            this.SetStatusFlag(NesPPUStatus.STATUS_VBLANK, true);
            this._request_end_frame = true;
            this._nmi_counter = 9;

            // Wrap around:
            this._scanline = -1; // will be incremented to 0
        }
        else
        {
            if (this._scanline >= 21 && this._scanline <= 260)
            {
                // Render normally:
                if (this._f_bg_visibility == 1)
                {
                    if (!this._scanline_already_rendered)
                    {
                        // update scroll:
                        this._cnt_ht = this._reg_ht;
                        this._cnt_h = this._reg_h;
                        this.RenderBgScanline(true, this._scanline + 1 - 21);
                    }
                    this._scanline_already_rendered = false;

                    // Check for sprite 0 (next scanline):
                    if (!this._hit_spr_0 && this._f_sp_visibility == 1)
                    {
                        if (this._spr_x[0] >= -7 &&
                            this._spr_x[0] < 256 &&
                            this._spr_y[0] + 1 <= this._scanline - 20 &&
                        	this._spr_y[0] + 1 + ConditionExpr(this._f_sprite_size == 0, 8, 16) >= this._scanline - 20)
                        {
                            if (this.CheckSprite0(this._scanline - 20))
                                this._hit_spr_0 = true;
                        }
                    }
                }

                if (this._f_bg_visibility == 1 || this._f_sp_visibility == 1)
                {
                    // Clock mapper IRQ Counter:
                    this._nes._mmap.ClockIrqCounter();
                }
            }
        }

        ++this._scanline;
        this.RegsToAddress();
        this.CntsToAddress();
    }

    public fun StartFrame()
    {
        // Set background color:
        var bgColor = 0;

        if (this._f_disp_type == 0) {
            // Color display.
            // _f_color determines color emphasis.
            // Use first entry of image palette as BG color.
            bgColor = this._img_palette[0];
        } else {
            // Monochrome display.
            // _f_color determines the bg color.
            if (this._f_color == 0) {
                // Black
                bgColor = 0x00000;
            }
            elseif (this._f_color == 1) {
                // Green
                bgColor = 0x00ff00;
            }
            elseif (this._f_color == 2) {
                // Blue
                bgColor = 0xff0000;
            }
            elseif (this._f_color == 3) {
                // Invalid. Use black.
                bgColor = 0x000000;
            }
            elseif (this._f_color == 4) {
                // Red
                bgColor = 0x0000ff;
            }
            else {
                // Invalid. Use black.
                bgColor = 0x0;
            }
        }

        var buffer = this._buffer;
        for (var i = 0; i < 256 * 240; 1)
            buffer[i] = bgColor;
        var pixrendered = this._pixrendered;
        for (var i = 0; i < PIXEL_COUNT; 1)
            pixrendered[i] = 65;
    }

    public fun EndFrame()
    {
        var buffer = this._buffer;

        // Draw spr#0 hit coordinates:
        if (this._show_spr_0_hit)
        {
            // Spr 0 position:
            if (this._spr_x[0] >= 0 && this._spr_x[0] < 256 && this._spr_y[0] >= 0 && this._spr_y[0] < 240)
            {
                for (var i = 0; i < 256; 1)
                    buffer[(this._spr_y[0] <<- 8) + i] = 0xff5555;

                for (var i = 0; i < 240; 1)
                    buffer[(i <<- 8) + this._spr_x[0]] = 0xff5555;
            }
            
            // Hit position:
            if (this._spr_0_hit_x >= 0 && this._spr_0_hit_x < 256 && this._spr_0_hit_y >= 0 && this._spr_0_hit_y < 240)
            {
                for (var i = 0; i < 256; 1)
                    buffer[(this._spr_0_hit_y <<- 8) + i] = 0x55ff55;
                for (var i = 0; i < 240; 1)
                	buffer[(i <<- 8) + this._spr_0_hit_x] = 0x55ff55;
            }
        }

        // This is a bit lazy..
        // if either the sprites or the background should be clipped,
        // both are clipped after rendering is finished.
        if ( this._clip_to_tv_size || this._f_bg_clipping == 0 || this._f_sp_clipping == 0) {
            // Clip left 8-pixels column:
            for (var y = 0; y < 240; 1) {
                for (var x = 0; x < 8; 1) {
                	buffer[(y <<- 8) + x] = 0;
                }
            }
        }

        if (this._clip_to_tv_size)
        {
            // Clip right 8-pixels column too:
            for (var y = 0; y < 240; 1) {
                for (var x = 0; x < 8; 1) {
                	buffer[(y <<- 8) + 255 - x] = 0;
                }
            }
        }

        // Clip top and bottom 8 pixels:
        if (this._clip_to_tv_size) {
            for (var y = 0; y < 8; 1) {
                for (var x = 0; x < 256; 1) {
        			buffer[(y <<- 8) + x] = 0;
                    buffer[((239 - y) <<- 8) + x] = 0;
            	}
            }
        }

        this._nes.OnFrame(buffer);
    }

    public fun UpdateControlReg1(int value)
    {
        this.TriggerRendering();

        this._f_nmi_on_vblank = (value ->> 7) & 1;
        this._f_sprite_size = (value ->> 5) & 1;
        this._f_bg_pattern_table = (value ->> 4) & 1;
        this._f_sp_pattern_table = (value ->> 3) & 1;
        this._f_addr_inc = (value ->> 2) & 1;
        this._f_ntbl_address = value & 3;

        this._reg_v = (value ->> 1) & 1;
        this._reg_h = value & 1;
        this._reg_s = (value ->> 4) & 1;
    }

    public fun UpdateControlReg2(int value)
    {
        this.TriggerRendering();

        this._f_color = (value ->> 5) & 7;
        this._f_sp_visibility = (value ->> 4) & 1;
        this._f_bg_visibility = (value ->> 3) & 1;
        this._f_sp_clipping = (value ->> 2) & 1;
        this._f_bg_clipping = (value ->> 1) & 1;
        this._f_disp_type = value & 1;

        if (this._f_disp_type == 0) {
            this._pal_table.SetEmphasis(this._f_color);
        }
        this.UpdatePalettes();
    }

    public fun SetStatusFlag(int flag, bool value)
    {
        var n = 1 <<- flag;
        this._nes._cpu._mem[0x2002] = (this._nes._cpu._mem[0x2002] & (255 - n)) | ConditionExpr(value, n, 0);
    }

    // CPU Register $2002:
    // Read the Status Register.
    public fun ReadStatusRegister() : int
    {
        var tmp = this._nes._cpu._mem[0x2002];

        // Reset scroll & VRAM Address toggle:
        this._first_write = true;

        // Clear VBlank flag:
        this.SetStatusFlag(NesPPUStatus.STATUS_VBLANK, false);

        // Fetch status data:
        return tmp;
    }

    // CPU Register $2003:
    // Write the SPR-RAM address that is used for sramWrite (Register 0x2004 in CPU memory map)
    public fun WriteSRAMAddress(int address)
    {
        this._sram_address = address;
    }

    // CPU Register $2004 (R):
    // Read from SPR-RAM (Sprite RAM).
    // The address should be set first.
    public fun SramLoad() : int
    {
        /*short tmp = sprMem.load(sramAddress);
        sramAddress++; // Increment address
        sramAddress%=0x100;
        return tmp;*/
        return this._sprite_mem[this._sram_address];
    }

    // CPU Register $2004 (W):
    // Write to SPR-RAM (Sprite RAM).
    // The address should be set first.
    public fun SramWrite(int value)
    {
        this._sprite_mem[this._sram_address] = value;
        this.SpriteRamWriteUpdate(this._sram_address, value);
        ++this._sram_address; // Increment address
        this._sram_address %= 0x100;
    }

    // CPU Register $2005:
    // Write to scroll registers.
    // The first write is the vertical offset, the second is the
    // horizontal offset:
    public fun ScrollWrite(int value)
    {
        this.TriggerRendering();

        if (this._first_write) {
            // First write, horizontal scroll:
            this._reg_ht = (value ->> 3) & 31;
            this._reg_fh = value & 7;
        } else {
            // Second write, vertical scroll:
            this._reg_fv = value & 7;
            this._reg_vt = (value ->> 3) & 31;
        }
        this._first_write = !this._first_write;
    }

    // CPU Register $2006:
    // Sets the adress used when reading/writing from/to VRAM.
    // The first write sets the high byte, the second the low byte.
    public fun WriteVRAMAddress(int address)
    {
        if (this._first_write) {
            this._reg_fv = (address ->> 4) & 3;
            this._reg_v = (address ->> 3) & 1;
            this._reg_h = (address ->> 2) & 1;
            this._reg_vt = (this._reg_vt & 7) | ((address & 3) <<- 3);
        } else {
            this.TriggerRendering();

            this._reg_vt = (this._reg_vt & 24) | ((address ->> 5) & 7);
            this._reg_ht = address & 31;

            this._cnt_fv = this._reg_fv;
            this._cnt_v = this._reg_v;
            this._cnt_h = this._reg_h;
            this._cnt_vt = this._reg_vt;
            this._cnt_ht = this._reg_ht;

            this.CheckSprite0(this._scanline - 20);
        }

        this._first_write = !this._first_write;

        // Invoke mapper latch:
        this.CntsToAddress();
        if (this._vram_address < 0x2000) {
        	this._nes._mmap.LatchAccess(this._vram_address);
        }
    }

    // CPU Register $2007(R):
    // Read from PPU memory. The address should be set first.
    public fun VramLoad() : int
    {
        var tmp = 0;

        this.CntsToAddress();
        this.RegsToAddress();

        // If address is in range 0x0000-0x3EFF, return buffered values:
        if (this._vram_address <= 0x3eff) {
            tmp = this._vram_buffered_read_value;

            // Update buffered value:
            if (this._vram_address < 0x2000) {
                this._vram_buffered_read_value = this._vram_mem[this._vram_address];
            } else {
                this._vram_buffered_read_value = this.MirroredLoad(this._vram_address);
            }

            // Mapper latch access:
            if (this._vram_address < 0x2000) {
                this._nes._mmap.LatchAccess(this._vram_address);
            }

            // Increment by either 1 or 32, depending on d2 of Control Register 1:
            this._vram_address += ConditionExpr(this._f_addr_inc == 1, 32, 1);

            this.CntsFromAddress();
            this.RegsFromAddress();

            return tmp; // Return the previous buffered value.
        }

        // No buffering in this mem range. Read normally.
        tmp = this.MirroredLoad(this._vram_address);

        // Increment by either 1 or 32, depending on d2 of Control Register 1:
        this._vram_address += ConditionExpr(this._f_addr_inc == 1, 32, 1);

        this.CntsFromAddress();
        this.RegsFromAddress();

        return tmp;
    }

    // CPU Register $2007(W):
    // Write to PPU memory. The address should be set first.
    public fun VramWrite(int value)
    {
        this.TriggerRendering();
        this.CntsToAddress();
        this.RegsToAddress();

        if (this._vram_address >= 0x2000) {
            // Mirroring is used.
            this.MirroredWrite(this._vram_address, value);
        } else {
            // Write normally.
            this.WriteMem(this._vram_address, value);

            // Invoke mapper latch:
            this._nes._mmap.LatchAccess(this._vram_address);
        }

        // Increment by either 1 or 32, depending on d2 of Control Register 1:
        if (this._f_addr_inc == 1)
        	this._vram_address += 32;
        else
            this._vram_address += 1;
        this.RegsFromAddress();
        this.CntsFromAddress();
    }

    // CPU Register $4014:
    // Write 256 bytes of main memory
    // into Sprite RAM.
    public fun SramDMA(int value)
    {
        var baseAddress = value * 0x100;
        var data = 0;
        for (var i = this._sram_address; i < 256; 1) {
            data = this._nes._cpu._mem[baseAddress + i];
            this._sprite_mem[i] = data;
            this.SpriteRamWriteUpdate(i, data);
        }

        this._nes._cpu.HaltCycles(513);
    }

    // Updates the scroll registers from a new VRAM address.
    public fun RegsFromAddress()
    {
        var address = (this._vram_tmp_address ->> 8) & 0xff;
        this._reg_fv = (address ->> 4) & 7;
        this._reg_v = (address ->> 3) & 1;
        this._reg_h = (address ->> 2) & 1;
        this._reg_vt = (this._reg_vt & 7) | ((address & 3) <<- 3);

        address = this._vram_tmp_address & 0xff;
        this._reg_vt = (this._reg_vt & 24) | ((address ->> 5) & 7);
        this._reg_ht = address & 31;
    }

    // Updates the scroll registers from a new VRAM address.
    public fun CntsFromAddress()
    {
        var address = (this._vram_address ->> 8) & 0xff;
        this._cnt_fv = (address ->> 4) & 3;
        this._cnt_v = (address ->> 3) & 1;
        this._cnt_h = (address ->> 2) & 1;
        this._cnt_vt = (this._cnt_vt & 7) | ((address & 3) <<- 3);

        address = this._vram_address & 0xff;
        this._cnt_vt = (this._cnt_vt & 24) | ((address ->> 5) & 7);
        this._cnt_ht = address & 31;
    }

    public fun RegsToAddress()
    {
        var b1 = (this._reg_fv & 7) <<- 4;
        b1 = b1 | (this._reg_v & 1) <<- 3;
        b1 = b1 | (this._reg_h & 1) <<- 2;
        b1 = b1 | (this._reg_vt ->> 3) & 3;

        var b2 = (this._reg_vt & 7) <<- 5;
        b2 = b2 |this._reg_ht & 31;

        this._vram_tmp_address = ((b1 <<- 8) | b2) & 0x7fff;
    }

    public fun CntsToAddress()
    {
        var b1 = (this._cnt_fv & 7) <<- 4;
        b1 = b1 | (this._cnt_v & 1) <<- 3;
        b1 = b1 | (this._cnt_h & 1) <<- 2;
        b1 = b1 | (this._cnt_vt ->> 3) & 3;

        var b2 = (this._cnt_vt & 7) <<- 5;
        b2 = b2 | this._cnt_ht & 31;

        this._vram_address = ((b1 <<- 8) | b2) & 0x7fff;
    }

    public fun IncTileCounter(int count)
    {
        for (var i = count; i != 0; -1) {
            ++this._cnt_ht;
            if (this._cnt_ht == 32) {
                this._cnt_ht = 0;
                ++this._cnt_vt;
                if (this._cnt_vt >= 30) {
                    ++this._cnt_h;
                    if (this._cnt_h == 2) {
                        this._cnt_h = 0;
                        ++this._cnt_v;
                        if (this._cnt_v == 2) {
                            this._cnt_v = 0;
                            ++this._cnt_fv;
                            this._cnt_fv = this._cnt_fv & 0x7;
                        }
                    }
                }
            }
        }
    }

    // Reads from memory, taking into account
    // mirroring/mapping of address ranges.
    public fun MirroredLoad(int address) : int
    {
        return this._vram_mem[this._vram_mirror_table[address]];
    }

    // Writes to memory, taking into account
    // mirroring/mapping of address ranges.
    public fun MirroredWrite(int address, int value)
    {
        if (address >= 0x3f00 && address < 0x3f20) {
            // Palette write mirroring.
            if (address == 0x3f00 || address == 0x3f10) {
                this.WriteMem(0x3f00, value);
                this.WriteMem(0x3f10, value);
            } else if (address == 0x3f04 || address == 0x3f14) {
                this.WriteMem(0x3f04, value);
                this.WriteMem(0x3f14, value);
            } else if (address == 0x3f08 || address == 0x3f18) {
                this.WriteMem(0x3f08, value);
                this.WriteMem(0x3f18, value);
            } else if (address == 0x3f0c || address == 0x3f1c) {
                this.WriteMem(0x3f0c, value);
                this.WriteMem(0x3f1c, value);
            } else {
                this.WriteMem(address, value);
            }
        } else {
            // Use lookup table for mirrored address:
            if (address < 0x8000) {
                this.WriteMem(this._vram_mirror_table[address], value);
            } else {
                ALittle.Log("Invalid VRAM address: "..address);
            }
        }
    }

    public fun TriggerRendering()
    {
        if (this._scanline >= 21 && this._scanline <= 260) {
            // Render sprites, and combine:
            this.RenderFramePartially(this._last_rendered_scanline + 1, this._scanline - 21 - this._last_rendered_scanline);

            // Set last rendered scanline:
            this._last_rendered_scanline = this._scanline - 21;
        }
    }

    public fun RenderFramePartially(int startScan, int scanCount)
    {
        if (this._f_sp_visibility == 1) {
            this.RenderSpritesPartially(startScan, scanCount, true);
        }

        if (this._f_bg_visibility == 1) {
            var si = startScan <<- 8;
            var ei = (startScan + scanCount) <<- 8;
            if (ei > 0xf000) {
                ei = 0xf000;
            }
            var buffer = this._buffer;
            var bgbuffer = this._bgbuffer;
            var pixrendered = this._pixrendered;
            for (var destIndex = si; destIndex < ei; 1) {
                if (pixrendered[destIndex] > 0xff) {
                    buffer[destIndex] = bgbuffer[destIndex];
                }
            }
        }

        if (this._f_sp_visibility == 1) {
            this.RenderSpritesPartially(startScan, scanCount, false);
        }

        this._valid_tile_data = false;
    }

    public fun RenderBgScanline(bool bgbuffer, int scan)
    {
        var baseTile = ConditionExpr(this._reg_s == 0, 0, 256);
        var destIndex = (scan <<- 8) - this._reg_fh;

        this._cur_nt = this._ntable_1[this._cnt_v + this._cnt_v + this._cnt_h];

        this._cnt_ht = this._reg_ht;
        this._cnt_h = this._reg_h;
        this._cur_nt = this._ntable_1[this._cnt_v + this._cnt_v + this._cnt_h];

        if (scan < 240 && scan - this._cnt_fv >= 0) {
            var tscanoffset = this._cnt_fv <<- 3;
            var scantile = this._scantile;
            var attrib = this._attrib;
            var ptTile = this._pt_tile;
            var nameTable = this._name_table;
            var imgPalette = this._img_palette;
            var pixrendered = this._pixrendered;
            var targetBuffer = this._buffer;
            if (bgbuffer != null) targetBuffer = this._bgbuffer;

            var t:NesTile;
            var tpix:Map<int, int>;
            var att = 0;
            var col = 0;

            for (var tile = 0; tile < 32; 1) {
                if (scan >= 0) {
                    // Fetch tile & attrib data:
                    if (this._valid_tile_data) {
                        // Get data from array:
                        t = scantile[tile];
                        if (t == null) {
                            continue;
                        }
                        tpix = t._pix;
                        att = attrib[tile];
                    } else {
                        // Fetch data:
                        t = ptTile[baseTile + nameTable[this._cur_nt].GetTileIndex(this._cnt_ht, this._cnt_vt)];
                        if (t == null) {
                            continue;
                        }
                        tpix = t._pix;
                        att = nameTable[this._cur_nt].GetAttrib(this._cnt_ht, this._cnt_vt);
                        scantile[tile] = t;
                        attrib[tile] = att;
                    }

                    // Render tile scanline:
                    var sx = 0;
                    var x = (tile <<- 3) - this._reg_fh;

                    if (x > -8) {
                        if (x < 0) {
                            destIndex -= x;
                            sx = -x;
                        }
                        if (t._opaque[this._cnt_fv]) {
                            while (sx < 8) {
                                targetBuffer[destIndex] =
                                imgPalette[tpix[tscanoffset + sx] + att];
                            	pixrendered[destIndex] = pixrendered[destIndex] | 256;
                            	++destIndex;
                            	++sx;
                            }
                        }
                        else {
                        	while (sx < 8) {
                                col = tpix[tscanoffset + sx];
                                if (col != 0) {
                                    targetBuffer[destIndex] = imgPalette[col + att];
                                	pixrendered[destIndex] = pixrendered[destIndex] | 256;
                                }
                                ++destIndex;
                                ++sx;
                            }
                        }
                    }
                }

                // Increase Horizontal Tile Counter:
                ++this._cnt_ht;
                if (this._cnt_ht == 32) {
                    this._cnt_ht = 0;
                    ++this._cnt_h;
                    this._cnt_h %= 2;
                    this._cur_nt = this._ntable_1[(this._cnt_v <<- 1) + this._cnt_h];
                }
            }

            // Tile data for one row should now have been fetched,
            // so the data in the array is valid.
            this._valid_tile_data = true;
        }

            // update vertical scroll:
        ++this._cnt_fv;
        if (this._cnt_fv == 8) {
            this._cnt_fv = 0;
            ++this._cnt_vt;
            if (this._cnt_vt == 30) {
                this._cnt_vt = 0;
                ++this._cnt_v;
                this._cnt_v %= 2;
                this._cur_nt = this._ntable_1[(this._cnt_v <<- 1) + this._cnt_h];
            } else if (this._cnt_vt == 32) {
                this._cnt_vt = 0;
            }

            // Invalidate fetched data:
            this._valid_tile_data = false;
        }
    }

    public fun RenderSpritesPartially(int startscan, int scancount, bool bgPri)
    {
        if (this._f_sp_visibility == 1)
        {
            for (var i = 0; i < 64; 1)
            {
                if (this._bg_priority[i] == bgPri && this._spr_x[i] >= 0 && this._spr_x[i] < 256 && this._spr_y[i] + 8 >= startscan && this._spr_y[i] < startscan + scancount)
                {
                    // Show sprite.
                    if (this._f_sprite_size == 0)
                    {
                        // 8x8 sprites
                        var srcy1 = 0;
                        var srcy2 = 8;

                        if (this._spr_y[i] < startscan) {
                            srcy1 = startscan - this._spr_y[i] - 1;
                        }

                        if (this._spr_y[i] + 8 > startscan + scancount) {
                            srcy2 = startscan + scancount - this._spr_y[i] + 1;
                        }

                        if (this._f_sp_pattern_table == 0) {
                            this._pt_tile[this._spr_tile[i]].Render(
                                                     this._buffer,
                                                     0,
                                                     srcy1,
                                                     8,
                                                     srcy2,
                                                     this._spr_x[i],
                                                     this._spr_y[i] + 1,
                                                     this._spr_col[i],
                                                     this._spr_palette,
                                                     this._hori_flip[i],
                                                     this._vert_flip[i],
                                                     i,
                                                     this._pixrendered
                                                     );
                        } else {
                            this._pt_tile[this._spr_tile[i] + 256].Render(
                                                           this._buffer,
                                                           0,
                                                           srcy1,
                                                           8,
                                                           srcy2,
                                                           this._spr_x[i],
                                                           this._spr_y[i] + 1,
                                                           this._spr_col[i],
                                                           this._spr_palette,
                                                           this._hori_flip[i],
                                                           this._vert_flip[i],
                                                           i,
                                                           this._pixrendered
                                                           );
                        }
                    } else {
                        // 8x16 sprites
                        var top = this._spr_tile[i];
                        if ((top & 1) != 0) {
                            top = this._spr_tile[i] - 1 + 256;
                        }

                        var srcy1 = 0;
                        var srcy2 = 8;

                        if (this._spr_y[i] < startscan) {
                            srcy1 = startscan - this._spr_y[i] - 1;
                        }

                        if (this._spr_y[i] + 8 > startscan + scancount) {
                            srcy2 = startscan + scancount - this._spr_y[i];
                        }

                        this._pt_tile[top + ConditionExpr(this._vert_flip[i], 1, 0)].Render(
                                            this._buffer,
                                            0,
                                            srcy1,
                                            8,
                                            srcy2,
                                            this._spr_x[i],
                                            this._spr_y[i] + 1,
                                            this._spr_col[i],
                                            this._spr_palette,
                                            this._hori_flip[i],
                                            this._vert_flip[i],
                                            i,
                                            this._pixrendered
                                            );

                        srcy1 = 0;
                        srcy2 = 8;

                        if (this._spr_y[i] + 8 < startscan) {
                        	srcy1 = startscan - (this._spr_y[i] + 8 + 1);
                        }

                        if (this._spr_y[i] + 16 > startscan + scancount) {
                        	srcy2 = startscan + scancount - (this._spr_y[i] + 8);
                        }

                        this._pt_tile[top + ConditionExpr(this._vert_flip[i], 0, 1)].Render(
                                            this._buffer,
                                            0,
                                            srcy1,
                                            8,
                                            srcy2,
                                            this._spr_x[i],
                                            this._spr_y[i] + 1 + 8,
                                            this._spr_col[i],
                                            this._spr_palette,
                                            this._hori_flip[i],
                                            this._vert_flip[i],
                                            i,
                                            this._pixrendered
                                            );
                    }
                }
            }
        }
    }

    public fun CheckSprite0(int scan) : bool
    {
        this._spr_0_hit_x = -1;
        this._spr_0_hit_y = -1;

        var toffset = 0;
        var tIndexAdd = ConditionExpr(this._f_sp_pattern_table == 0, 0, 256);
        var bufferIndex = 0;

        var x = this._spr_x[0];
        var y = this._spr_y[0] + 1;

        var t:NesTile;

        if (this._f_sprite_size == 0) {
            // 8x8 sprites.

            // Check range:
            if (y <= scan && y + 8 > scan && x >= -7 && x < 256) {
                // Sprite is in range.
                // Draw scanline:
                t = this._pt_tile[this._spr_tile[0] + tIndexAdd];

                if (this._vert_flip[0]) {
                    toffset = 7 - (scan - y);
                } else {
                    toffset = scan - y;
                }
                toffset *= 8;

                bufferIndex = scan * 256 + x;
                if (this._hori_flip[0]) {
                    for (var i = 7; i >= 0; -1) {
                        if (x >= 0 && x < 256) {
                            if (bufferIndex >= 0 && bufferIndex < 61440 && this._pixrendered[bufferIndex] != 0) {
                                if (t._pix[toffset + i] != 0) {
                                    this._spr_0_hit_x = bufferIndex % 256;
                                    this._spr_0_hit_y = scan;
                                    return true;
                                }
                            }
                        }
                        ++x;
                        ++bufferIndex;
                    }
                } else {
                    for (var i = 0; i < 8; 1) {
                        if (x >= 0 && x < 256) {
                            if (bufferIndex >= 0 && bufferIndex < 61440 && this._pixrendered[bufferIndex] != 0) {
                                if (t._pix[toffset + i] != 0) {
                                    this._spr_0_hit_x = bufferIndex % 256;
                                    this._spr_0_hit_y = scan;
                                    return true;
                                }
                            }
                        }
                        ++x;
                        ++bufferIndex;
                    }
                }
            }
        } else {
            // 8x16 sprites:

            // Check range:
            if (y <= scan && y + 16 > scan && x >= -7 && x < 256)
            {
                // Sprite is in range.
                // Draw scanline:

                if (this._vert_flip[0]) {
                    toffset = 15 - (scan - y);
                } else {
                    toffset = scan - y;
                }

                if (toffset < 8) {
                    // first half of sprite.
                    t = this._pt_tile[this._spr_tile[0] + ConditionExpr(this._vert_flip[0], 1, 0) + ConditionExpr((this._spr_tile[0] & 1) != 0, 255, 0)];
                } else {
                    // second half of sprite.
                    t = this._pt_tile[this._spr_tile[0] + ConditionExpr(this._vert_flip[0], 0, 1) + ConditionExpr((this._spr_tile[0] & 1) != 0, 255, 0)];
                    if (this._vert_flip[0]) {
                    	toffset = 15 - toffset;
                    } else {
                    	toffset -= 8;
                    }
                }
                toffset *= 8;

                bufferIndex = scan * 256 + x;
                if (this._hori_flip[0]) {
                    for (var i = 7; i >= 0; -1) {
                    	if (x >= 0 && x < 256) {
                    		if (bufferIndex >= 0 && bufferIndex < 61440 && this._pixrendered[bufferIndex] != 0) {
                    			if (t._pix[toffset + i] != 0) {
                    				this._spr_0_hit_x = bufferIndex % 256;
                    				this._spr_0_hit_y = scan;
                    				return true;
                    			}
                    		}
                    	}
                        ++x;
                        ++bufferIndex;
                    }
                } else {
                    for (var i = 0; i < 8; 1) {
                    	if (x >= 0 && x < 256) {
                    		if (bufferIndex >= 0 && bufferIndex < 61440 && this._pixrendered[bufferIndex] != 0) {
                    			if (t._pix[toffset + i] != 0) {
                                    this._spr_0_hit_x = bufferIndex % 256;
                                    this._spr_0_hit_y = scan;
                                    return true;
                    			}
                    		}
                    	}
                    	++x;
                    	++bufferIndex;
                	}
                }
            }
        }

        return false;
    }

    // This will write to PPU memory, and
    // update internally buffered data
    // appropriately.
    public fun WriteMem(int address, int value)
    {
        this._vram_mem[address] = value;

        // Update internally buffered data:
        if (address < 0x2000) {
            this._vram_mem[address] = value;
            this.PatternWrite(address, value);
        } else if (address >= 0x2000 && address < 0x23c0) {
            this.NameTableWrite(this._ntable_1[0], address - 0x2000, value);
        } else if (address >= 0x23c0 && address < 0x2400) {
            this.AttribTableWrite(this._ntable_1[0], address - 0x23c0, value);
        } else if (address >= 0x2400 && address < 0x27c0) {
            this.NameTableWrite(this._ntable_1[1], address - 0x2400, value);
        } else if (address >= 0x27c0 && address < 0x2800) {
            this.AttribTableWrite(this._ntable_1[1], address - 0x27c0, value);
        } else if (address >= 0x2800 && address < 0x2bc0) {
            this.NameTableWrite(this._ntable_1[2], address - 0x2800, value);
        } else if (address >= 0x2bc0 && address < 0x2c00) {
            this.AttribTableWrite(this._ntable_1[2], address - 0x2bc0, value);
        } else if (address >= 0x2c00 && address < 0x2fc0) {
            this.NameTableWrite(this._ntable_1[3], address - 0x2c00, value);
        } else if (address >= 0x2fc0 && address < 0x3000) {
            this.AttribTableWrite(this._ntable_1[3], address - 0x2fc0, value);
        } else if (address >= 0x3f00 && address < 0x3f20) {
            this.UpdatePalettes();
        }
    }

    // Reads data from $3f00 to $f20
    // into the two buffered palettes.
    public fun UpdatePalettes()
    {
        for (var i = 0; i < 16; 1) {
            if (this._f_disp_type == 0) {
                this._img_palette[i] = this._pal_table.GetEntry(
                                                      this._vram_mem[0x3f00 + i] & 63
                                                      );
            } else {
                this._img_palette[i] = this._pal_table.GetEntry(
                                                      this._vram_mem[0x3f00 + i] & 32
                                                      );
            }
        }
        for (var i = 0; i < 16; 1) {
            if (this._f_disp_type == 0) {
                this._spr_palette[i] = this._pal_table.GetEntry(
                                                      this._vram_mem[0x3f10 + i] & 63
                                                      );
            } else {
                this._spr_palette[i] = this._pal_table.GetEntry(
                                                      this._vram_mem[0x3f10 + i] & 32
                                                      );
            }
        }
    }

    // Updates the internal pattern
    // table buffers with this new byte.
    // In vNES, there is a version of this with 4 arguments which isn't used.
    public fun PatternWrite(int address, int value)
    {
        var tileIndex = ALittle.Math_Floor(address / 16);
        var leftOver = address % 16;
        if (leftOver < 8) {
            this._pt_tile[tileIndex].SetScanline(
                                          leftOver,
                                          value,
                                          this._vram_mem[address + 8]
                                          );
        } else {
            this._pt_tile[tileIndex].SetScanline(
                                          leftOver - 8,
                                          this._vram_mem[address - 8],
                                          value
                                          );
        }
    }

    // Updates the internal name table buffers
    // with this new byte.
    public fun NameTableWrite(int index, int address, int value)
    {
        this._name_table[index]._tile[address] = value;

        // Update Sprite #0 hit:
        //updateSpr0Hit();
        this.CheckSprite0(this._scanline - 20);
    }

    // Updates the internal pattern
    // table buffers with this new attribute
    // table byte.
    public fun AttribTableWrite(int index, int address, int value)
    {
        this._name_table[index].WriteAttrib(address, value);
    }

    // Updates the internally buffered sprite
    // data with this new byte of info.
    public fun SpriteRamWriteUpdate(int address, int value)
    {
        var tIndex = ALittle.Math_Floor(address / 4);

        if (tIndex == 0) {
            //updateSpr0Hit();
            this.CheckSprite0(this._scanline - 20);
        }

        if (address % 4 == 0) {
            // Y coordinate
            this._spr_y[tIndex] = value;
        } else if (address % 4 == 1) {
            // Tile index
            this._spr_tile[tIndex] = value;
        } else if (address % 4 == 2) {
            // Attributes
            this._vert_flip[tIndex] = (value & 0x80) != 0;
            this._hori_flip[tIndex] = (value & 0x40) != 0;
            this._bg_priority[tIndex] = (value & 0x20) != 0;
            this._spr_col[tIndex] = (value & 3) <<- 2;
        } else if (address % 4 == 3) {
            // X coordinate
            this._spr_x[tIndex] = value;
        }
    }

    public fun DoNMI()
    {
        // Set VBlank flag:
        this.SetStatusFlag(NesPPUStatus.STATUS_VBLANK, true);
        //nes.getCpu().doNonMaskableInterrupt();
        this._nes._cpu.RequestIrq(NesCPUIRQ.IRQ_NMI);
    }

    public fun IsPixelWhite(int x, int y) : bool
    {
        this.TriggerRendering();
        return this._buffer[(y <<- 8) + x] == 0xffffff;
    }
}
