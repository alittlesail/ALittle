
namespace ALittle;

private var error = lua.error;

// 创建一张表
public static Create() : any
{
    return new Map<any, any>();
}

// 设置弱引用
public static Setweak(any table, bool key, bool value)
{
    if (!key && !value)
    {
        lua.setmetatable(table, null);
        return;
    }

    var mode = "";
    if (key) mode = "k";
    if (value) mode = mode.."v";
    var mt = new Map<string, string>();
    mt["__mode"] = mode;
    lua.setmetatable(table, mt);
}

public static Push<T>(List<T> list, T object)
{
    lua.table.insert(list, cast<int>(object));
}

public static DateInfo(@Nullable int time) : lua.dateinfo
{
    return cast<lua.dateinfo>(lua.os.date("*t", time));
}

public static RandInt(int min, int max) : int
{
    return cast<int>(lua.math.random(min, max));
}

public static Find(string content, string substring) : int, int
{
    return lua.String.find(content, substring, 1, true);
}

// 提供给关键字tcall使用
protected static TCall(...) : string
{
    var out_list:List<any> = [lua.pcall(...)];
    // 如果第一个参数不是true，说明第二个调用失败的原因
    if (out_list[1] != true)
    {
        if (out_list[2] == null) return "nil";
        return out_list[2];
    }
    // 先获取当前list的长度
    var l = lua.table.maxn(out_list);
    // 把第一个设置为空
    out_list[1] = null;
    // 最后展开返回
    return lua.unpack(out_list, 1, l);
}

// 提供关键字throw使用
protected static Throw(string msg)
{
    error(msg);
}

// 提供关键字assert使用
protected static Assert(any value, string msg)
{
    if (value != null && value != false) return;
    if (msg == null) msg = "Assert failed";
    error(msg);
}

// 时间常量
public enum TimeSecond
{
    ONE_MINUTE_SECONDS = 60;		// 每分钟对应的秒数
    ONE_HOUR_SECONDS = 3600;	    // 每小时对应的秒数
    ONE_DAY_SECONDS = 86400;	    // 一天的秒数
    ONE_WEEK_DAY = 7;				// 一周需要的天数
    ONE_WEEK_SECONDS = 604800;		// 一周需要的秒数
}

// 获取明天开始的时间
public static GetNextTodayBeginTime() : int
{
    var date = DateInfo();
    date.hour = 0;
    date.min = 0;
    date.sec = 0;
    return lua.os.time(date) + TimeSecond.ONE_DAY_SECONDS;
}

// 获取最新的版本时间
private var __VersionTime = 0;
private var __VersionIndex = 0;
public static NewTimeAndIndex() : int, int
{
    var cur_time = lua.os.time();
    if (__VersionTime == cur_time)
        __VersionIndex = __VersionIndex + 1;
    elseif (cur_time > __VersionTime)
    {
        __VersionTime = cur_time;
        __VersionIndex = 0;
    }
    return __VersionTime, __VersionIndex;
}
